<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ project_name }} - {{ entry.title }}</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="stylesheet" href="{{ url_for('static', filename='notifications_modern.css') }}">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <style>
        body {
            background-color: #f8f9fa;
        }
        .container {
            margin-top: 30px;
            background-color: #ffffff;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            margin-bottom: 30px;
        }
        .form-control, .form-select {
            margin-bottom: 15px;
        }
        .note-item {
            background-color: #ffffff;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 15px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transition: all 0.2s ease-in-out;
        }
        .note-item:hover {
            border-color: #007bff;
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
            transform: translateY(-1px);
        }
        .note-item h5 {
            margin-top: 0;
            font-size: 1.1rem;
            color: #343a40;
            border-bottom: 1px solid #dee2e6;
            padding-bottom: 8px;
            margin-bottom: 12px;
        }
        .note-item p {
            font-size: 0.9rem;
            color: #495057;
            line-height: 1.4;
        }
        .note-actions button {
            margin-left: 5px;
        }
        .relationship-item {
            background-color: #f0f8ff; /* Light blue background for relationships */
            border: 1px solid #cceeff;
            border-radius: 5px;
            padding: 15px;
            margin-bottom: 10px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }
        .relationship-item h5 {
            margin-top: 0;
            font-size: 1.1rem;
            color: #0056b3;
        }
        .relationship-item p {
            font-size: 0.9rem;
            color: #495057;
        }
        .relationship-actions button {
            margin-left: 5px;
        }
        /* New styles for inline note form */
        .placeholder-section {
            border: 1px dashed #ced4da;
            padding: 20px;
            text-align: center;
            color: #6c757d;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        #newNoteForm.collapse:not(.show) {
            display: none;
        }
        #newNoteForm.collapsing {
            height: 0;
            overflow: hidden;
            transition: height 0.35s ease;
        }
        #newNoteForm.collapse.show {
            height: auto;
        }
        /* Style for the modal note content to preserve line breaks and ensure expansion */
        #modalNoteContent {
            white-space: pre-wrap; /* Preserves whitespace and wraps text */
        }
        /* Ensure modals are responsive */
        @media (max-width: 576px) {
            .modal-dialog {
                margin: 0.5rem;
            }
        }
        /* Style for disabled relationship buttons */
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .btn:disabled:hover {
            opacity: 0.5;
        }
        
        /* Content section styling */
        .content-section {
            background: white;
            border-radius: 12px;
            border-left: 4px solid #6c757d;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            overflow: hidden;
        }
        
        .section-content {
            padding: 1.5rem;
        }
        
        .section-header {
            display: flex;
            justify-content-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
        }
        
        .section-title {
            color: #495057;
            font-weight: 600;
            margin: 0;
            display: flex;
            align-items: center;
        }
        
        .content-subsection {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 1rem;
            border: 1px solid #e9ecef;
        }
        
        .info-card {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 1rem;
            border: 1px solid #e9ecef;
            height: 100%;
        }
        
        .info-label {
            font-size: 0.85rem;
            font-weight: 600;
            color: #6c757d;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 0.5rem;
        }
        
        .info-value {
            font-size: 1rem;
            color: #212529;
            font-weight: 500;
        }
        
        /* Mobile responsiveness */
        @media (max-width: 768px) {
            .section-content {
                padding: 1rem;
            }
            
            .section-header {
                flex-direction: column;
                align-items: stretch;
            }
            
            .entry-actions {
                width: 100%;
                justify-content: center;
            }
        }

        /* Label Grid Styles */
        .label-grid-container {
            border: 2px solid #dee2e6;
            border-radius: 8px;
            padding: 10px;
            background: #f8f9fa;
            max-width: 200px;
        }

        .label-row {
            display: flex;
            gap: 5px;
            margin-bottom: 5px;
        }

        .label-row:last-child {
            margin-bottom: 0;
        }

        .label-position {
            width: 80px;
            height: 40px;
            border: 2px solid #dee2e6;
            border-radius: 4px;
            background: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 500;
            font-size: 12px;
        }

        .label-position:hover {
            border-color: #007bff;
            background: #e3f2fd;
            transform: translateY(-1px);
        }

        .label-position.selected {
            background: #007bff;
            color: white;
            border-color: #0056b3;
        }

        .label-position.selected:hover {
            background: #0056b3;
        }
    </style>
</head>
<body>
    <div class="container-fluid">
        <!-- Header Section -->
        <div class="content-section mb-4">
            <div class="section-content">
                <nav aria-label="breadcrumb" class="mb-3">
                    <ol class="breadcrumb">
                        <li class="breadcrumb-item"><a href="{{ url_for('main.index') }}" class="text-decoration-none">
                            <i class="fas fa-home me-1"></i>Home</a></li>
                        <li class="breadcrumb-item active" aria-current="page">{{ entry.title }}</li>
                    </ol>
                </nav>

                <div class="d-flex flex-column flex-md-row justify-content-between align-items-start align-items-md-center mb-3">
                    <h1 class="h3 mb-2 mb-md-0" id="entryTitle">{{ entry.title }}</h1>
                    <div class="entry-actions d-flex flex-wrap gap-2">
                        <button class="btn btn-sm btn-outline-secondary" id="editDescriptionBtn" type="button"
                                data-bs-toggle="collapse" data-bs-target="#descriptionEditor" 
                                aria-expanded="false" aria-controls="descriptionEditor">
                            <i class="fas fa-edit me-1"></i>Edit Entry
                        </button>
                        {% if entry.show_labels_section %}
                        <button class="btn btn-sm btn-outline-primary" id="manageLabelBtn" type="button" 
                                data-bs-toggle="collapse" data-bs-target="#labelPrintingSection" 
                                aria-expanded="false" aria-controls="labelPrintingSection">
                            <i class="fas fa-tags me-1"></i>Labels
                        </button>
                        {% endif %}
                        <button class="btn btn-sm btn-danger" id="deleteEntryBtn">
                            <i class="fas fa-trash-alt me-1"></i>Delete
                        </button>
                    </div>
                </div>

                <div class="row g-3">
                    <div class="col-md-4">
                        <div class="info-card">
                            <div class="info-label">Details</div>
                            <div class="info-value" id="detailsDisplay">
                                <div><strong>Type:</strong> <span id="entryTypeDisplay">{{ entry.entry_type_label }}</span></div>
                                <div><strong>Status:</strong> <span id="statusDisplay">{{ (entry.status or 'active').title() }}</span></div>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-8">
                        <div class="info-card">
                            <div class="info-label">Dates</div>
                            <div class="info-value" id="datesDisplay">
                                <div><strong>Created On:</strong> <span id="created-at">{{ entry.created_at }}</span></div>
                                {% if entry.intended_end_date and entry.show_end_dates %}
                                <div><strong>Intended End:</strong> <span id="intended-end-date-display">{{ entry.intended_end_date[:10] if entry.intended_end_date else '' }}</span></div>
                                {% endif %}
                                {% if entry.actual_end_date and entry.show_end_dates %}
                                <div><strong>Actual End:</strong> <span id="actual-end-date-display">{{ entry.actual_end_date[:10] if entry.actual_end_date else '' }}</span></div>
                                {% endif %}
                            </div>
                        </div>
                    </div>
                </div>

                <div class="mt-3">
                    <div class="info-card">
                        <div class="info-label">Description</div>
                        <div class="info-value" id="descriptionDisplay">{{ entry.description or 'No description available' }}</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Collapsible Labels Section -->
        {% if entry.show_labels_section %}
        <div class="collapse mb-4" id="labelPrintingSection">
            <div class="content-section">
                <div class="section-content">
                    <div class="section-header mb-3">
                        <h4 class="section-title">
                            <i class="fas fa-tags me-2"></i>Label Printing
                        </h4>
                    </div>
                    
                    <div class="row g-3">
                        <div class="col-md-6">
                            <div class="mb-3">
                                <label for="labelTypeSelect" class="form-label">Label Sheet Type</label>
                                <select class="form-select" id="labelTypeSelect">
                                    <option value="8_labels">8 Labels (2x4) - Larger</option>
                                    <option value="14_labels">14 Labels (2x7) - Smaller</option>
                                </select>
                            </div>
                            <div class="mb-3">
                                <label for="labelRotationSelect" class="form-label">Label Orientation</label>
                                <select class="form-select" id="labelRotationSelect">
                                    <option value="0">Normal (0°)</option>
                                    <option value="90">Rotated (90°)</option>
                                </select>
                            </div>
                            <div class="mb-3">
                                <div id="labelPositionContainer">
                                    <!-- Position grid will be populated dynamically -->
                                </div>
                            </div>
                            <div class="d-flex flex-wrap gap-2 mb-3">
                                <button type="button" class="btn btn-outline-primary" id="previewLabelBtn">
                                    <i class="fas fa-eye me-1"></i>Preview
                                </button>
                                <button type="button" class="btn btn-success" id="printLabelBtn">
                                    <i class="fas fa-print me-1"></i>Print Page
                                </button>
                                <button type="button" class="btn btn-info" id="downloadLabelPdfBtn">
                                    <i class="fas fa-download me-1"></i>Download PDF
                                </button>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <div id="labelPreviewContainer" class="text-center">
                                <div class="border rounded p-3 bg-light">
                                    <p class="text-muted">Click "Preview" to see how your label will look</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div id="labelStatusMessage" class="mt-3 d-none"></div>
                </div>
            </div>
        </div>
        {% endif %}

        <div class="row g-4">
            <div class="col-lg-7">
                <!-- Collapsible Entry Editor -->
                <div class="collapse mb-4" id="descriptionEditor">
                    <div class="content-section">
                        <div class="section-content">
                            <div class="section-header mb-3">
                                <h5 class="section-title">
                                    <i class="fas fa-edit me-2"></i>Edit Entry
                                </h5>
                            </div>
                            
                            <div class="mb-3">
                                <label for="entryTitleInput" class="form-label">Entry Title</label>
                                <input type="text" class="form-control" id="entryTitleInput" value="{{ entry.title }}" placeholder="Enter entry title">
                            </div>
                            <div class="mb-3">
                                <label for="entryTypeSelect" class="form-label">Entry Type</label>
                                <select class="form-select" id="entryTypeSelect">
                                    <!-- Options will be loaded dynamically -->
                                </select>
                            </div>
                            <div class="mb-3">
                                <label for="descriptionTextarea" class="form-label">Entry Description</label>
                                <textarea class="form-control" id="descriptionTextarea" rows="6" placeholder="Add a detailed description for this entry...">{{ entry.description if entry.description is not none else '' }}</textarea>
                            </div>
                            <div class="row g-3">
                                <div class="col-md-{{ '4' if entry.show_end_dates else '12' }}">
                                    <div class="mb-3">
                                        <label for="statusSelect" class="form-label">Status</label>
                                        <select class="form-select" id="statusSelect">
                                            <option value="active" {{ 'selected' if entry.status == 'active' else '' }}>Active</option>
                                            <option value="inactive" {{ 'selected' if entry.status == 'inactive' else '' }}>Inactive</option>
                                        </select>
                                    </div>
                                </div>
                                {% if entry.show_end_dates %}
                                <div class="col-md-4">
                                    <div class="mb-3">
                                        <label for="intendedEndDateInput" class="form-label">Intended End Date</label>
                                        <input type="date" class="form-control" id="intendedEndDateInput" value="{{ entry.intended_end_date[:10] if entry.intended_end_date else '' }}">
                                    </div>
                                </div>
                                <div class="col-md-4">
                                    <div class="mb-3">
                                        <label for="actualEndDateInput" class="form-label">Actual End Date</label>
                                        <input type="date" class="form-control" id="actualEndDateInput" value="{{ entry.actual_end_date[:10] if entry.actual_end_date else '' }}">
                                    </div>
                                </div>
                                {% endif %}
                            </div>
                            <div class="d-flex flex-wrap gap-2 mb-3">
                                <button type="button" class="btn btn-success" id="saveDescriptionBtn">
                                    <i class="fas fa-save me-1"></i>Save Changes
                                </button>
                                <button type="button" class="btn btn-outline-primary" id="searchWikipediaBtn">
                                    <i class="fab fa-wikipedia-w me-1"></i>Search Wikipedia
                                </button>
                                <button type="button" class="btn btn-secondary" id="cancelDescriptionBtn">
                                    <i class="fas fa-times me-1"></i>Cancel
                                </button>
                            </div>
                            <div id="descriptionStatusMessage" class="mt-3 d-none"></div>
                            
                            <!-- Wikipedia Results -->
                            <div id="wikipediaResults" class="mt-3 d-none">
                                <div class="content-subsection">
                                    <div class="section-header mb-3">
                                        <h6 class="section-title">
                                            <i class="fab fa-wikipedia-w me-2"></i>Wikipedia Result
                                        </h6>
                                    </div>
                                    <h6 id="wikipediaTitle" class="fw-bold"></h6>
                                    <p id="wikipediaExtract" class="text-muted"></p>
                                    <div class="d-flex flex-wrap gap-2">
                                        <button type="button" class="btn btn-sm btn-primary" id="useWikipediaBtn">Use This Description</button>
                                        <a id="wikipediaLink" href="#" target="_blank" class="btn btn-sm btn-outline-secondary">View on Wikipedia</a>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <hr class="my-4">

                {% if entry.has_sensors %}
                <div class="content-section mb-4">
                    <div class="section-content">
                        <div class="section-header mb-3">
                            <h4 class="section-title">
                                <i class="fas fa-chart-line me-2"></i>Sensor Data
                            </h4>
                        </div>
                        
                        <!-- Chart/Table Toggle Buttons -->
                        <div class="btn-group mb-3" role="group" aria-label="Data view options">
                            <input type="radio" class="btn-check" name="viewOptions" id="tableView">
                            <label class="btn btn-outline-primary" for="tableView">
                                <i class="fas fa-table me-1"></i>Table View
                            </label>
                            
                            <input type="radio" class="btn-check" name="viewOptions" id="chartView" checked>
                            <label class="btn btn-outline-primary" for="chartView">
                                <i class="fas fa-chart-line me-1"></i>Chart View
                            </label>
                        </div>
                        
                        <!-- Sensor Data Container (hidden by default) -->
                        <div id="sensorDataContainer" style="display: none;">
                            <p class="text-muted text-center" id="loadingSensorData">Loading sensor data...</p>
                            <!-- Sensor data will be loaded here -->
                        </div>
                        
                        <!-- Chart Container (visible by default) -->
                        <div id="sensorChartContainer">
                            <p class="text-muted text-center" id="loadingChart">Loading chart...</p>
                            <div class="mb-3">
                                <canvas id="sensorChart" width="400" height="200"></canvas>
                            </div>
                            
                            <!-- Chart Options -->
                            <div class="row g-3">
                                <div class="col-md-4">
                                    <label for="chartTypeSelect" class="form-label">Chart Type</label>
                                    <select class="form-select form-select-sm" id="chartTypeSelect">
                                        <option value="line">Line Chart</option>
                                        <option value="bar">Bar Chart</option>
                                        <option value="scatter">Scatter Plot</option>
                                    </select>
                                </div>
                                <div class="col-md-4">
                                    <label for="sensorTypeFilter" class="form-label">Filter by Sensor Type</label>
                                    <select class="form-select form-select-sm" id="sensorTypeFilter">
                                        <option value="all">All Sensor Types</option>
                                        <!-- Options will be populated dynamically -->
                                    </select>
                                </div>
                                <div class="col-md-4">
                                    <label for="timeRangeFilter" class="form-label">Time Range</label>
                                    <select class="form-select form-select-sm" id="timeRangeFilter">
                                        <option value="all">All Time</option>
                                        <option value="24h">Last 24 Hours</option>
                                        <option value="7d">Last 7 Days</option>
                                        <option value="30d">Last 30 Days</option>
                                    </select>
                                </div>
                            </div>
                        </div>
                        
                        <button class="btn btn-primary btn-sm" type="button" data-bs-toggle="modal" data-bs-target="#addSensorDataModal">
                            <i class="fas fa-plus-circle me-2"></i>Add Sensor Reading
                        </button>
                    </div>
                </div>
                {% endif %}

                <div class="content-section mb-4" id="relatedRecordsSection" style="display: none;">
                    <div class="section-content">
                        <div class="section-header mb-3">
                            <h4 class="section-title">
                                <i class="fas fa-link me-2"></i>Related Records
                            </h4>
                        </div>
                        <div id="relatedRecordsContainer">
                            <p class="text-muted text-center" id="loadingRelationships">Loading relationships...</p>
                        </div>
                    </div>
                </div>
            </div>

            <div class="col-lg-5">
                <div class="content-section">
                    <div class="section-content">
                        <div class="section-header mb-3">
                            <h4 class="section-title">
                                <i class="fas fa-sticky-note me-2"></i>Notes
                            </h4>
                            <button class="btn btn-primary btn-sm" type="button" data-bs-toggle="collapse" data-bs-target="#newNoteForm" aria-expanded="false" aria-controls="newNoteForm">
                                <i class="fas fa-plus-circle me-2"></i><span id="toggleNewNoteText">Add New Note</span>
                            </button>
                        </div>

                        <div class="collapse mb-3" id="newNoteForm">
                            <div class="content-subsection">
                                <div class="mb-3">
                                    <label for="noteTitleInput" class="form-label">Title</label>
                                    <input type="text" class="form-control" id="noteTitleInput" placeholder="Provide a title">
                                </div>
                                <div class="mb-3">
                                    <label for="noteTypeSelect" class="form-label">Type</label>
                                    <select class="form-select" id="noteTypeSelect">
                                        {# Options will be dynamically populated by JavaScript based on entry.note_types #}
                                    </select>
                                </div>
                                <div class="mb-3">
                                    <label for="newNoteTextarea" class="form-label">Notes</label>
                                    <textarea class="form-control" id="newNoteTextarea" rows="4" placeholder="Type your new note here..."></textarea>
                                </div>
                                <div class="mb-3">
                                    <label for="reminderDateInput" class="form-label">
                                        <i class="fas fa-bell text-warning me-1"></i>Set Reminder Date & Time
                                    </label>
                                    <input type="datetime-local" class="form-control" id="reminderDateInput" 
                                           min="" placeholder="Choose reminder date and time">
                                    <div class="form-text">
                                        <i class="fas fa-info-circle me-1"></i> 
                                        A notification will appear at this exact date and time. 
                                        <strong>Note:</strong> If you select a date, you must also select a time (defaults to 1:00 AM if not specified).
                                    </div>
                                    <div class="mt-2">
                                        <button type="button" class="btn btn-sm btn-outline-secondary me-2" onclick="setReminderToToday()">
                                            <i class="fas fa-calendar-day me-1"></i>Today
                                        </button>
                                        <button type="button" class="btn btn-sm btn-outline-secondary me-2" onclick="setReminderToTomorrow()">
                                            <i class="fas fa-calendar-plus me-1"></i>Tomorrow
                                        </button>
                                        <button type="button" class="btn btn-sm btn-outline-secondary" onclick="clearReminder()">
                                            <i class="fas fa-times me-1"></i>Clear
                                        </button>
                                    </div>
                                </div>
                                <hr>
                                <div class="mb-3">
                                    <label for="fileUploadInput" class="form-label">Upload Files (Optional)</label>
                                    <input type="file" class="form-control" id="fileUploadInput" multiple>
                                    <div id="selectedFilesInfo" class="mt-2 small text-muted">No files selected.</div>
                                    <div class="form-text">
                                        <i class="fas fa-info-circle me-1"></i> 
                                        Supported file types: Images (JPG, PNG, GIF, WebP), Documents (PDF, DOC, DOCX, TXT), 
                                        Archives (ZIP, RAR), Videos (MP4, AVI, MOV), and more.
                                        <br><strong>Max file size:</strong> 50MB per file
                                    </div>
                                </div>
                                <button type="button" class="btn btn-primary" id="addNoteBtn">
                                    <i class="fas fa-plus-circle me-1"></i>Save Note
                                </button>
                                <div id="noteStatusMessage" class="mt-3 d-none"></div>
                            </div>
                        </div>

                        <div id="notesList" class="mt-4">
                            <p class="text-muted" id="noNotesMessage">Loading notes...</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Note Detail Modal (Still a modal for full view) -->
    <div class="modal fade" id="noteDetailModal" tabindex="-1" aria-labelledby="noteDetailModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="noteDetailModalLabel">Note Details</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <p><strong>Title:</strong> <span id="modalNoteTitle"></span></p>
                    <p><strong>Type:</strong> <span id="modalNoteType"></span></p>
                    <p><strong>Created On:</strong> <span id="modalNoteCreated"></span></p>
                    
                    <!-- Reminder Section -->
                    <div id="modalNoteReminder" style="display: none;">
                        <div id="reminderDisplayMode">
                            <p><strong>Reminder:</strong> 
                                <span id="modalReminderDate" class="text-info"></span>
                                <span id="modalReminderStatus" class="badge ms-2"></span>
                                <button type="button" class="btn btn-sm btn-outline-primary ms-2" id="editReminderBtn">
                                    <i class="fas fa-edit me-1"></i>Edit
                                </button>
                            </p>
                        </div>
                        
                        <!-- Edit Reminder Form -->
                        <div id="reminderEditMode" style="display: none;">
                            <div class="mb-3">
                                <label for="editReminderDate" class="form-label">Reminder Date:</label>
                                <input type="date" class="form-control" id="editReminderDate">
                            </div>
                            <div class="mb-3">
                                <label for="editReminderTime" class="form-label">Reminder Time:</label>
                                <input type="time" class="form-control" id="editReminderTime" value="01:00">
                            </div>
                            <div class="d-flex gap-2">
                                <button type="button" class="btn btn-sm btn-success" id="saveReminderBtn">
                                    <i class="fas fa-save me-1"></i>Save
                                </button>
                                <button type="button" class="btn btn-sm btn-secondary" id="cancelReminderEditBtn">
                                    Cancel
                                </button>
                                <button type="button" class="btn btn-sm btn-danger" id="deleteReminderBtn">
                                    <i class="fas fa-trash me-1"></i>Remove Reminder
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <h6>Content:</h6>
                    <div id="noteContentDisplay">
                        <p id="modalNoteContent"></p>
                        <button type="button" class="btn btn-sm btn-outline-primary" id="editNoteContentBtn">
                            <i class="fas fa-edit me-1"></i>Edit Note
                        </button>
                    </div>
                    
                    <!-- Edit Note Content Form -->
                    <div id="noteContentEditMode" style="display: none;">
                        <div class="mb-3">
                            <label for="editNoteTitle" class="form-label">Note Title:</label>
                            <input type="text" class="form-control" id="editNoteTitle">
                        </div>
                        <div class="mb-3">
                            <label for="editNoteText" class="form-label">Note Content:</label>
                            <textarea class="form-control" id="editNoteText" rows="4"></textarea>
                        </div>
                        <div class="d-flex gap-2">
                            <button type="button" class="btn btn-sm btn-success" id="saveNoteContentBtn">
                                <i class="fas fa-save me-1"></i>Save Changes
                            </button>
                            <button type="button" class="btn btn-sm btn-secondary" id="cancelNoteContentEditBtn">
                                Cancel
                            </button>
                        </div>
                    </div>
                    
                    <hr>
                    <div class="d-flex justify-content-between align-items-center mb-3">
                        <h6 class="mb-0">Attached Files:</h6>
                        <button type="button" class="btn btn-sm btn-outline-success" id="addAttachmentsBtn">
                            <i class="fas fa-paperclip me-1"></i>Add Files
                        </button>
                    </div>
                    
                    <!-- Add Attachments Form -->
                    <div id="addAttachmentsForm" style="display: none;" class="mb-3">
                        <div class="mb-3">
                            <label for="additionalFiles" class="form-label">Select files to attach:</label>
                            <input type="file" class="form-control" id="additionalFiles" multiple>
                            <div class="form-text">Maximum file size: 50MB per file</div>
                        </div>
                        <div class="d-flex gap-2">
                            <button type="button" class="btn btn-sm btn-success" id="uploadAdditionalFilesBtn">
                                <i class="fas fa-upload me-1"></i>Upload Files
                            </button>
                            <button type="button" class="btn btn-sm btn-secondary" id="cancelAddAttachmentsBtn">
                                Cancel
                            </button>
                        </div>
                    </div>
                    
                    <div id="modalNoteFiles" class="row row-cols-1 row-cols-md-2 g-2">
                        <div class="col" id="noAttachmentsPlaceholder">
                            <div class="placeholder-section" style="min-height: 150px; display: flex; align-items: center; justify-content: center;">
                                <p>No files attached yet.</p>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                    <button type="button" class="btn btn-danger" id="deleteNoteFromModalBtn">
                        <i class="fas fa-trash-alt me-1"></i> Delete Note
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Add Relationship Modal (Still a modal) -->
    <div class="modal fade" id="addRelatedEntryModal" tabindex="-1" aria-labelledby="addRelatedEntryModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="addRelatedEntryModalLabel">Add Related <span id="modalRelatedEntryTypeLabel"></span></h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <form id="addRelatedEntryForm">
                        <input type="hidden" id="currentRelationshipDefId">
                        <p>Relating from: <strong>{{ entry.title }} ({{ entry.entry_type_label }})</strong></p>

                        <div class="mb-3">
                            <label for="relatedEntrySelect" class="form-label">Select Existing <span id="selectLabelEntryType"></span>:</label>
                            <select class="form-select" id="relatedEntrySelect">
                                <option value="">Search or Select...</option>
                            </select>
                        </div>
                        <div class="mb-3" id="newRelatedEntryNameGroup" style="display:none;">
                            <label for="newRelatedEntryName" class="form-label">New <span id="newLabelEntryType"></span> Name:</label>
                            <input type="text" class="form-control" id="newRelatedEntryName">
                        </div>
                        <div class="form-check mb-3">
                            <input class="form-check-input" type="checkbox" id="createNewRelatedEntryCheckbox">
                            <label class="form-check-label" for="createNewRelatedEntryCheckbox">
                                Create a New <span id="createLabelEntryType"></span> instead
                            </label>
                        </div>

                        <div class="row" id="quantityUnitFields" style="display: none;">
                            <div class="col-md-6 mb-3">
                                <label for="relatedQuantity" class="form-label">Quantity:</label>
                                <input type="number" step="any" class="form-control" id="relatedQuantity">
                            </div>
                            <div class="col-md-6 mb-3">
                                <label for="relatedUnit" class="form-label">Unit:</label>
                                <input type="text" class="form-control" id="relatedUnit">
                            </div>
                        </div>
                        <button type="submit" class="btn btn-primary">Add Relationship</button>
                    </form>
                </div>
            </div>
        </div>
    </div>

    <!-- Add New Relationship Modal -->
    <div class="modal fade" id="addNewRelationshipModal" tabindex="-1" aria-labelledby="addNewRelationshipModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="addNewRelationshipModalLabel">Add New Relationship</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <form id="addNewRelationshipForm">
                        <div class="mb-3">
                            <label for="newEntryName" class="form-label">Entry Name</label>
                            <input type="text" class="form-control" id="newEntryName" placeholder="Enter new entry name" required>
                        </div>
                        <div class="mb-3">
                            <label for="newEntryDescription" class="form-label">Description</label>
                            <textarea class="form-control" id="newEntryDescription" rows="3" placeholder="Enter description"></textarea>
                            <div class="mt-2">
                                <button type="button" class="btn btn-sm btn-outline-primary" id="searchWikipediaNewRelationBtn">
                                    <i class="fab fa-wikipedia-w me-1"></i> Search Wikipedia
                                </button>
                            </div>
                        </div>
                        <div id="wikipediaNewRelationResults" class="mb-3 d-none">
                            <div class="card border-info">
                                <div class="card-header bg-light">
                                    <h6 class="mb-0"><i class="fab fa-wikipedia-w me-1"></i> Wikipedia Result</h6>
                                </div>
                                <div class="card-body">
                                    <h6 id="wikipediaNewRelationTitle" class="card-title"></h6>
                                    <p id="wikipediaNewRelationExtract" class="card-text" style="font-size: 0.9em; max-height: 100px; overflow-y: auto;"></p>
                                    <div class="d-flex gap-2">
                                        <button type="button" class="btn btn-sm btn-gray" id="useWikipediaNewRelationBtn">Use This Description</button>
                                        <a id="wikipediaNewRelationLink" href="#" target="_blank" class="btn btn-sm btn-outline-secondary">View on Wikipedia</a>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <button type="submit" class="btn btn-primary">Add</button>
                    </form>
                </div>
            </div>
        </div>
    </div>

    <!-- Add Existing Relationship Modal -->
    <div class="modal fade" id="addExistingRelationshipModal" tabindex="-1" aria-labelledby="addExistingRelationshipModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="addExistingRelationshipModalLabel">Add Existing Relationship</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <form id="addExistingRelationshipForm">
                        <div class="mb-3">
                            <label for="existingEntrySelect" class="form-label">Select Entry</label>
                            <select class="form-select" id="existingEntrySelect" required>
                                <option value="" disabled selected>Select an entry</option>
                                <!-- Options will be dynamically populated -->
                            </select>
                        </div>
                        <button type="submit" class="btn btn-primary">Add</button>
                    </form>
                </div>
            </div>
        </div>
    </div>

    <!-- Add Sensor Data Modal -->
    {% if entry.has_sensors %}
    <div class="modal fade" id="addSensorDataModal" tabindex="-1" aria-labelledby="addSensorDataModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="addSensorDataModalLabel">Add Sensor Reading</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <form id="addSensorDataForm">
                        <div class="mb-3">
                            <label for="sensorTypeInput" class="form-label">Sensor Type:</label>
                            <select class="form-select" id="sensorTypeInput" required>
                                <option value="" disabled selected>Select a sensor type</option>
                                <!-- Options will be dynamically populated -->
                            </select>
                        </div>
                        <div class="mb-3">
                            <label for="sensorValueInput" class="form-label">Value:</label>
                            <input type="text" class="form-control" id="sensorValueInput" placeholder="e.g., 23.5°C, 65%, 1013.2 hPa" required>
                        </div>
                        <div class="mb-3">
                            <label for="sensorRecordedAt" class="form-label">Recorded At:</label>
                            <input type="datetime-local" class="form-control" id="sensorRecordedAt">
                        </div>
                        <button type="submit" class="btn btn-primary">Add Reading</button>
                    </form>
                </div>
            </div>
        </div>
    </div>
    {% endif %}

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // Data injected from Flask/Jinja
        const entryId = "{{ entry.id }}";
        const entryTypeNoteTypesRaw = "{{ entry.note_types | default('General', true) }}";
        const currentEntryTypeId = "{{ entry.entry_type_id }}"; // Needed for related records
        const currentEntryName = {{ entry.title|tojson }}; // Using title as name for consistency
        const currentEntryTypeLabel = {{ entry.entry_type_label|tojson }};
        const hasSensors = {{ entry.has_sensors|tojson }}; // Convert to JavaScript boolean
        const enabledSensorTypes = "{{ entry.enabled_sensor_types | default('', true) }}"; // Entry type's enabled sensor types

        // DOM elements for Notes and Description (existing)
        const noteTitleInput = document.getElementById('noteTitleInput');
        const noteTypeSelect = document.getElementById('noteTypeSelect');
        const newNoteTextarea = document.getElementById('newNoteTextarea');
        const fileUploadInput = document.getElementById('fileUploadInput');
        const selectedFilesInfo = document.getElementById('selectedFilesInfo');
        const addNoteBtn = document.getElementById('addNoteBtn');
        const notesList = document.getElementById('notesList');
        const noNotesMessage = document.getElementById('noNotesMessage');
        const noteStatusMessage = document.getElementById('noteStatusMessage');
        const descriptionTextarea = document.getElementById('descriptionTextarea');
        const entryTitleInput = document.getElementById('entryTitleInput');
        const entryTypeSelect = document.getElementById('entryTypeSelect');
        const statusSelect = document.getElementById('statusSelect');
        {% if entry.show_end_dates %}
        const intendedEndDateInput = document.getElementById('intendedEndDateInput');
        const actualEndDateInput = document.getElementById('actualEndDateInput');
        {% endif %}
        const saveDescriptionBtn = document.getElementById('saveDescriptionBtn');
        const editDescriptionBtn = document.getElementById('editDescriptionBtn');
        const cancelDescriptionBtn = document.getElementById('cancelDescriptionBtn');
        const descriptionDisplay = document.getElementById('descriptionDisplay');
        const entryTitle = document.getElementById('entryTitle');
        const entryTypeDisplay = document.getElementById('entryTypeDisplay');
        const statusDisplay = document.getElementById('statusDisplay');
        const detailsDisplay = document.getElementById('detailsDisplay');
        const datesDisplay = document.getElementById('datesDisplay');
        const intendedEndDateDisplay = document.getElementById('intended-end-date-display');
        const actualEndDateDisplay = document.getElementById('actual-end-date-display');
        const descriptionEditor = document.getElementById('descriptionEditor');
        const descriptionStatusMessage = document.getElementById('descriptionStatusMessage');
        const createdAtSpan = document.getElementById('created-at');
        const newNoteFormCollapseElement = document.getElementById('newNoteForm');
        const toggleNewNoteText = document.getElementById('toggleNewNoteText');

        // Modal elements for note detail (existing)
        const noteDetailModal = new bootstrap.Modal(document.getElementById('noteDetailModal'));
        const modalNoteTitle = document.getElementById('modalNoteTitle');
        const modalNoteType = document.getElementById('modalNoteType');
        const modalNoteCreated = document.getElementById('modalNoteCreated');
        const modalNoteContent = document.getElementById('modalNoteContent');
        const modalNoteFiles = document.getElementById('modalNoteFiles');
        const deleteNoteFromModalBtn = document.getElementById('deleteNoteFromModalBtn');

        // Reminder editing elements
        const editReminderBtn = document.getElementById('editReminderBtn');
        const reminderDisplayMode = document.getElementById('reminderDisplayMode');
        const reminderEditMode = document.getElementById('reminderEditMode');
        const editReminderDate = document.getElementById('editReminderDate');
        const editReminderTime = document.getElementById('editReminderTime');
        const saveReminderBtn = document.getElementById('saveReminderBtn');
        const cancelReminderEditBtn = document.getElementById('cancelReminderEditBtn');
        const deleteReminderBtn = document.getElementById('deleteReminderBtn');

        // Note content editing elements
        const editNoteContentBtn = document.getElementById('editNoteContentBtn');
        const noteContentDisplay = document.getElementById('noteContentDisplay');
        const noteContentEditMode = document.getElementById('noteContentEditMode');
        const editNoteTitle = document.getElementById('editNoteTitle');
        const editNoteText = document.getElementById('editNoteText');
        const saveNoteContentBtn = document.getElementById('saveNoteContentBtn');
        const cancelNoteContentEditBtn = document.getElementById('cancelNoteContentEditBtn');

        // Attachment management elements
        const addAttachmentsBtn = document.getElementById('addAttachmentsBtn');
        const addAttachmentsForm = document.getElementById('addAttachmentsForm');
        const additionalFiles = document.getElementById('additionalFiles');
        const uploadAdditionalFilesBtn = document.getElementById('uploadAdditionalFilesBtn');
        const cancelAddAttachmentsBtn = document.getElementById('cancelAddAttachmentsBtn');
        const noAttachmentsPlaceholder = document.getElementById('noAttachmentsPlaceholder');

        // Map to store fetched notes by ID for quick lookup
        let loadedNotes = new Map();
        let currentNoteIdInModal = null; // To keep track of which note is open in the modal
        let noteTypeColors = null; // Cache for note type colors

        // Function to get note type color
        function getNoteTypeColor(noteType) {
            // Default colors for standard note types
            const defaultColors = {
                'general': '#0dcaf0',
                'info': '#0dcaf0',
                'important': '#dc3545',
                'critical': '#dc3545',
                'warning': '#fd7e14',
                'caution': '#fd7e14',
                'success': '#198754',
                'completed': '#198754'
            };
            
            // Check if we have custom note types loaded
            if (noteTypeColors && noteTypeColors[noteType.toLowerCase()]) {
                return noteTypeColors[noteType.toLowerCase()];
            }
            
            // Fall back to default colors
            const lowerType = noteType.toLowerCase();
            return defaultColors[lowerType] || '#6f42c1'; // Purple for unknown types
        }

        // Load custom note type colors from system parameters
        async function loadNoteTypeColors() {
            try {
                const response = await fetch('/api/system_params');
                const params = await response.json();
                
                if (params.custom_note_types) {
                    const customTypes = JSON.parse(params.custom_note_types);
                    noteTypeColors = {};
                    
                    customTypes.forEach(noteType => {
                        noteTypeColors[noteType.name.toLowerCase()] = noteType.color;
                    });
                }
            } catch (error) {
                console.error('Error loading note type colors:', error);
            }
        }

        // DOM elements for Related Records (new)
        const relatedRecordsContainer = document.getElementById('relatedRecordsContainer');
        const loadingRelationships = document.getElementById('loadingRelationships');
        const addRelatedEntryModal = new bootstrap.Modal(document.getElementById('addRelatedEntryModal'));
        const addRelatedEntryForm = document.getElementById('addRelatedEntryForm');
        const relatedEntrySelect = document.getElementById('relatedEntrySelect');
        const createNewRelatedEntryCheckbox = document.getElementById('createNewRelatedEntryCheckbox');
        const newRelatedEntryNameGroup = document.getElementById('newRelatedEntryNameGroup');
        const newRelatedEntryName = document.getElementById('newRelatedEntryName');
        const quantityUnitFields = document.getElementById('quantityUnitFields');
        const relatedQuantity = document.getElementById('relatedQuantity');
        const relatedUnit = document.getElementById('relatedUnit');

        let allRelationshipDefinitions = []; // Store definitions for easy lookup
        let allPossibleRelatedEntries = {}; // Cache entries for dropdowns by type ID

        // Chart variables for sensor data
        let sensorChart = null;
        let allSensorData = []; // Store all sensor data for filtering and charting
        let chartTypeSelect, sensorTypeFilter, timeRangeFilter, tableViewBtn, chartViewBtn, sensorChartContainer;

        // Format the created_at timestamp
        if (createdAtSpan && createdAtSpan.textContent) {
            try {
                const date = new Date(createdAtSpan.textContent);
                createdAtSpan.textContent = date.toLocaleString();
            } catch (e) {
                console.error("Error parsing date:", e);
            }
        }

        // Function to update the consolidated dates display
        function updateDatesDisplay(intendedEndDate, actualEndDate) {
            {% if entry.show_end_dates %}
            if (datesDisplay) {
                let datesHtml = '<div><strong>Created On:</strong> <span id="created-at">' + createdAtSpan.textContent + '</span></div>';
                
                if (intendedEndDate && intendedEndDate !== '') {
                    datesHtml += '<div><strong>Intended End:</strong> <span id="intended-end-date-display">' + intendedEndDate + '</span></div>';
                }
                
                if (actualEndDate && actualEndDate !== '') {
                    datesHtml += '<div><strong>Actual End:</strong> <span id="actual-end-date-display">' + actualEndDate + '</span></div>';
                }
                
                datesDisplay.innerHTML = datesHtml;
            }
            {% endif %}
        }

        // Function to update the consolidated details display
        function updateDetailsDisplay(entryType, status) {
            if (detailsDisplay) {
                let detailsHtml = '<div><strong>Type:</strong> <span id="entryTypeDisplay">' + entryType + '</span></div>';
                detailsHtml += '<div><strong>Status:</strong> <span id="statusDisplay">' + status + '</span></div>';
                detailsDisplay.innerHTML = detailsHtml;
                
                // Update individual references for compatibility
                const updatedEntryTypeDisplay = document.getElementById('entryTypeDisplay');
                const updatedStatusDisplay = document.getElementById('statusDisplay');
                if (updatedEntryTypeDisplay) updatedEntryTypeDisplay.textContent = entryType;
                if (updatedStatusDisplay) updatedStatusDisplay.textContent = status;
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            initializeNoteTypeDropdown();
            loadNoteTypeColors(); // Load custom note type colors
            fetchNotes();
            loadRelatedRecords(); // Call the new function to load related records
            if (hasSensors) {
                loadSensorData(); // Load sensor data if this entry type supports sensors
                initializeSensorDataForm(); // Initialize sensor data form
                initializeChartControls(); // Initialize chart controls
            }
        });

        function initializeNoteTypeDropdown() {
            const noteTypes = entryTypeNoteTypesRaw.split(',').map(type => type.trim()).filter(type => type !== '');
            noteTypeSelect.innerHTML = '';

            if (noteTypes.length === 0) {
                const option = document.createElement('option');
                option.value = 'General';
                option.textContent = 'General';
                noteTypeSelect.appendChild(option);
            } else {
                noteTypes.forEach(type => {
                    const option = document.createElement('option');
                    option.value = type;
                    option.textContent = type;
                    noteTypeSelect.appendChild(option);
                });
            }
        }

        // Bootstrap collapse event listener to update button text
        newNoteFormCollapseElement.addEventListener('shown.bs.collapse', () => {
            toggleNewNoteText.textContent = 'Hide New Note Form';
        });
        newNoteFormCollapseElement.addEventListener('hidden.bs.collapse', () => {
            toggleNewNoteText.textContent = 'Add New Note';
        });

        // Handle file selection change
        fileUploadInput.addEventListener('change', () => {
            if (fileUploadInput.files.length > 0) {
                let fileList = Array.from(fileUploadInput.files).map(file => {
                    const sizeInMB = (file.size / (1024 * 1024)).toFixed(2);
                    return `${file.name} (${sizeInMB} MB)`;
                }).join(', ');
                selectedFilesInfo.innerHTML = `<strong>Selected:</strong> ${fileList}`;
                selectedFilesInfo.classList.remove('text-muted');
                selectedFilesInfo.classList.add('text-info');
            } else {
                selectedFilesInfo.textContent = 'No files selected.';
                selectedFilesInfo.classList.remove('text-info');
                selectedFilesInfo.classList.add('text-muted');
            }
        });

        // --- Notes Section (Add Note) ---
        const reminderDateInput = document.getElementById('reminderDateInput');
        
        // Set minimum date to today
        const now = new Date();
        now.setMinutes(now.getMinutes() - now.getTimezoneOffset()); // Adjust for timezone
        reminderDateInput.min = now.toISOString().slice(0, 16);
        
        // Add event listener to ensure time is set when date is selected
        reminderDateInput.addEventListener('change', function() {
            const value = this.value;
            if (value) {
                // Check if only date is provided (no time part)
                if (value.length === 10) {
                    // Date only, append default time of 01:00 (1 AM)
                    this.value = value + 'T01:00';
                } else if (value.includes('T') && value.split('T')[1] === '') {
                    // Date with T but no time, append default time
                    this.value = value + '01:00';
                }
            }
        });
        
        // Helper functions for reminder date buttons
        function setReminderToToday() {
            const today = new Date();
            today.setHours(today.getHours() + 1); // Set to 1 hour from now
            today.setMinutes(0); // Round to nearest hour
            today.setSeconds(0);
            today.setMilliseconds(0);
            today.setMinutes(today.getMinutes() - today.getTimezoneOffset()); // Adjust for timezone
            reminderDateInput.value = today.toISOString().slice(0, 16);
        }
        
        function setReminderToTomorrow() {
            const tomorrow = new Date();
            tomorrow.setDate(tomorrow.getDate() + 1);
            tomorrow.setHours(1); // Set to 1 AM tomorrow (default time)
            tomorrow.setMinutes(0);
            tomorrow.setSeconds(0);
            tomorrow.setMilliseconds(0);
            tomorrow.setMinutes(tomorrow.getMinutes() - tomorrow.getTimezoneOffset()); // Adjust for timezone
            reminderDateInput.value = tomorrow.toISOString().slice(0, 16);
        }
        
        function clearReminder() {
            reminderDateInput.value = '';
        }
        
        // Make functions global so onclick can access them
        window.setReminderToToday = setReminderToToday;
        window.setReminderToTomorrow = setReminderToTomorrow;
        window.clearReminder = clearReminder;
        
        addNoteBtn.addEventListener('click', async () => {
            const noteTitle = noteTitleInput.value.trim();
            const noteText = newNoteTextarea.value.trim();
            const noteType = noteTypeSelect.value;
            let reminderDate = reminderDateInput.value;
            const files = fileUploadInput.files;

            if (!noteText) {
                displayStatus(noteStatusMessage, 'Note content cannot be empty.', 'alert-warning');
                return;
            }

            // Validate file sizes (50MB max per file)
            const maxFileSize = 50 * 1024 * 1024; // 50MB in bytes
            for (let file of files) {
                if (file.size > maxFileSize) {
                    displayStatus(noteStatusMessage, `File "${file.name}" is too large. Maximum file size is 50MB.`, 'alert-warning');
                    return;
                }
            }

            // Validate reminder date if provided
            if (reminderDate) {
                // Ensure complete datetime format
                if (reminderDate.length === 10) {
                    // Only date provided, append default time of 01:00
                    reminderDate = reminderDate + 'T01:00';
                    reminderDateInput.value = reminderDate; // Update the input field
                } else if (reminderDate.includes('T') && reminderDate.split('T')[1] === '') {
                    // Date with T but no time
                    reminderDate = reminderDate + '01:00';
                    reminderDateInput.value = reminderDate; // Update the input field
                } else if (reminderDate.length === 16 && !reminderDate.includes('T')) {
                    // Invalid format - require proper datetime
                    displayStatus(noteStatusMessage, 'Please select both date and time for the reminder.', 'alert-warning');
                    return;
                }
                
                // Validate that the reminder date is in the future
                const reminderDateTime = new Date(reminderDate);
                const now = new Date();
                if (reminderDateTime <= now) {
                    displayStatus(noteStatusMessage, 'Reminder date and time must be in the future.', 'alert-warning');
                    return;
                }
            }

            displayStatus(noteStatusMessage, 'Adding note...', 'alert-info');

            try {
                // Use FormData for file uploads
                const formData = new FormData();
                formData.append('note_title', noteTitle);
                formData.append('note_text', noteText);
                formData.append('note_type', noteType);
                
                // Add reminder date if provided
                if (reminderDate) {
                    formData.append('reminder_date', reminderDate);
                }
                
                // Add files if any
                for (let file of files) {
                    formData.append('files', file);
                }
                
                const response = await fetch(`/api/entries/${entryId}/notes`, {
                    method: 'POST',
                    body: formData  // Don't set Content-Type header, let browser set it with boundary
                });

                const data = await response.json();

                if (response.ok) {
                    displayStatus(noteStatusMessage, 'Note added successfully!', 'alert-success');
                    noteTitleInput.value = '';
                    newNoteTextarea.value = '';
                    reminderDateInput.value = '';
                    noteTypeSelect.value = noteTypeSelect.options[0].value;
                    fileUploadInput.value = '';
                    selectedFilesInfo.textContent = 'No files selected.';
                    selectedFilesInfo.classList.remove('text-info');
                    selectedFilesInfo.classList.add('text-muted');

                    const bsCollapse = new bootstrap.Collapse(newNoteFormCollapseElement, { toggle: false });
                    bsCollapse.hide(); // Hide the form after successful submission
                    fetchNotes(); // Refresh the notes list
                } else {
                    displayStatus(noteStatusMessage, `Error: ${data.message || 'Failed to add note.'}`, 'alert-danger');
                }
            } catch (error) {
                console.error('Network or server error:', error);
                displayStatus(noteStatusMessage, 'An unexpected error occurred while adding note.', 'alert-danger');
            }
        });

        async function fetchNotes() {
            noNotesMessage.textContent = 'Loading notes...';
            notesList.innerHTML = '';
            notesList.appendChild(noNotesMessage);
            try {
                const response = await fetch(`/api/entries/${entryId}/notes`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const notes = await response.json();

                loadedNotes.clear();
                notes.forEach(note => {
                    loadedNotes.set(parseInt(note.id), note);
                });

                displayNotes(notes);
            } catch (error) {
                console.error('Error fetching notes:', error);
                noNotesMessage.textContent = 'Failed to load notes.';
                noNotesMessage.classList.add('text-danger');
            }
        }

        function displayNotes(notes) {
            notesList.innerHTML = '';
            if (notes.length === 0) {
                noNotesMessage.textContent = 'No notes yet.';
                notesList.appendChild(noNotesMessage);
                return;
            }
            if (noNotesMessage.parentNode === notesList) {
                noNotesMessage.remove();
            }

            notes.forEach(note => {
                const noteItem = document.createElement('div');
                noteItem.classList.add('list-group-item', 'list-group-item-action', 'flex-column', 'align-items-start', 'mb-3', 'border-2', 'rounded');
                
                // Color-code border based on note type
                let borderColor = getNoteTypeColor(note.note_type);
                
                noteItem.style.cssText = `border-left: 4px solid ${borderColor} !important; box-shadow: 0 2px 4px rgba(0,0,0,0.1); transition: all 0.2s ease; background-color: rgba(${borderColor === '#007bff' ? '0,123,255' : borderColor === '#dc3545' ? '220,53,69' : borderColor === '#fd7e14' ? '253,126,20' : borderColor === '#198754' ? '25,135,84' : borderColor === '#0dcaf0' ? '13,202,240' : '111,66,193'}, 0.02); padding: 1.25rem !important;`;
                
                // Add hover effect
                noteItem.addEventListener('mouseenter', () => {
                    noteItem.style.boxShadow = '0 4px 8px rgba(0,0,0,0.15)';
                    noteItem.style.transform = 'translateY(-1px)';
                });
                noteItem.addEventListener('mouseleave', () => {
                    noteItem.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)';
                    noteItem.style.transform = 'translateY(0)';
                });
                
                // Create reminder indicator if present
                let reminderIndicator = '';
                if (note.reminder) {
                    const reminderDate = new Date(note.reminder.scheduled_for);
                    const now = new Date();
                    const isPast = reminderDate <= now;
                    const isRead = note.reminder.is_read;
                    const isDismissed = note.reminder.is_dismissed;
                    
                    let iconClass = 'fas fa-bell';
                    let colorClass = 'text-warning';
                    let title = `Reminder set for ${reminderDate.toLocaleString()}`;
                    
                    if (isDismissed) {
                        iconClass = 'fas fa-bell-slash';
                        colorClass = 'text-muted';
                        title = 'Reminder dismissed';
                    } else if (isPast && !isRead) {
                        iconClass = 'fas fa-bell';
                        colorClass = 'text-danger';
                        title = `Reminder was due ${reminderDate.toLocaleString()}`;
                    } else if (isPast && isRead) {
                        iconClass = 'fas fa-bell-slash';
                        colorClass = 'text-success';
                        title = 'Reminder completed';
                    }
                    
                    reminderIndicator = `<i class="${iconClass} ${colorClass} ms-2" title="${title}"></i>`;
                }
                
                // Create attachment indicator if present
                let attachmentIndicator = '';
                if (note.file_paths && note.file_paths.length > 0) {
                    const fileCount = note.file_paths.length;
                    const title = fileCount === 1 ? '1 file attached' : `${fileCount} files attached`;
                    attachmentIndicator = `<i class="fas fa-paperclip text-info ms-2" title="${title}"></i>`;
                }
                
                noteItem.innerHTML = `
                    <div class="d-flex w-100 justify-content-between">
                        <h5 class="mb-1">
                            ${note.note_title ? note.note_title : 'No Title'} 
                            <small class="text-muted">(${note.note_type})</small>
                            ${reminderIndicator}
                            ${attachmentIndicator}
                        </h5>
                        <small>${new Date(note.created_at).toLocaleString()}</small>
                    </div>
                    <p class="mb-1">${note.note_text.substring(0, 100)}${note.note_text.length > 100 ? '...' : ''}</p>
                    <button type="button" class="btn btn-outline-secondary btn-sm mt-2 open-note-details-btn" data-note-id="${note.id}">
                        Open Details <i class="fas fa-external-link-alt ms-1"></i>
                    </button>
                `;
                notesList.appendChild(noteItem);
            });

            notesList.querySelectorAll('.open-note-details-btn').forEach(button => {
                button.addEventListener('click', (event) => {
                    const noteId = parseInt(event.currentTarget.dataset.noteId);
                    const note = loadedNotes.get(noteId);

                    if (note) {
                        currentNoteIdInModal = noteId;
                        modalNoteTitle.textContent = note.note_title || 'No Title';
                        modalNoteType.textContent = note.note_type || 'General';
                        modalNoteCreated.textContent = new Date(note.created_at).toLocaleString();
                        modalNoteContent.textContent = note.note_text;
                        
                        // Handle reminder information
                        const modalNoteReminder = document.getElementById('modalNoteReminder');
                        const modalReminderDate = document.getElementById('modalReminderDate');
                        const modalReminderStatus = document.getElementById('modalReminderStatus');
                        
                        if (note.reminder) {
                            modalNoteReminder.style.display = 'block';
                            const reminderDate = new Date(note.reminder.scheduled_for);
                            modalReminderDate.textContent = reminderDate.toLocaleString();
                            
                            // Set status badge
                            const now = new Date();
                            const isPast = reminderDate <= now;
                            const isRead = note.reminder.is_read;
                            const isDismissed = note.reminder.is_dismissed;
                            
                            if (isDismissed) {
                                modalReminderStatus.className = 'badge bg-secondary ms-2';
                                modalReminderStatus.textContent = 'Dismissed';
                            } else if (isPast && !isRead) {
                                modalReminderStatus.className = 'badge bg-danger ms-2';
                                modalReminderStatus.textContent = 'Overdue';
                            } else if (isPast && isRead) {
                                modalReminderStatus.className = 'badge bg-success ms-2';
                                modalReminderStatus.textContent = 'Completed';
                            } else {
                                modalReminderStatus.className = 'badge bg-warning text-dark ms-2';
                                modalReminderStatus.textContent = 'Scheduled';
                            }
                        } else {
                            modalNoteReminder.style.display = 'none';
                        }
                        
                        // Display attached files
                        displayNoteFiles(note);

                        noteDetailModal.show();
                    } else {
                        alert("Could not load note details. Please try again.");
                    }
                });
            });
        }

        // Function to display note files in the modal
        function displayNoteFiles(note) {
            modalNoteFiles.innerHTML = '';
            
            if (note.file_paths && note.file_paths.length > 0) {
                note.file_paths.forEach((filePath, index) => {
                    const fileName = filePath.split('/').pop();
                    const fileExtension = fileName.split('.').pop().toLowerCase();
                    const fileDiv = document.createElement('div');
                    fileDiv.classList.add('col');
                    
                    // Determine file type and icon
                    let fileIcon = 'fas fa-file';
                    let isImage = false;
                    
                    if (['jpg', 'jpeg', 'png', 'gif', 'webp', 'svg'].includes(fileExtension)) {
                        fileIcon = 'fas fa-image';
                        isImage = true;
                    } else if (['pdf'].includes(fileExtension)) {
                        fileIcon = 'fas fa-file-pdf';
                    } else if (['doc', 'docx'].includes(fileExtension)) {
                        fileIcon = 'fas fa-file-word';
                    } else if (['txt'].includes(fileExtension)) {
                        fileIcon = 'fas fa-file-alt';
                    } else if (['zip', 'rar', '7z'].includes(fileExtension)) {
                        fileIcon = 'fas fa-file-archive';
                    } else if (['mp4', 'avi', 'mov', 'mkv'].includes(fileExtension)) {
                        fileIcon = 'fas fa-file-video';
                    } else if (['mp3', 'wav', 'flac'].includes(fileExtension)) {
                        fileIcon = 'fas fa-file-audio';
                    }
                    
                    if (isImage) {
                        fileDiv.innerHTML = `
                            <div class="file-attachment position-relative">
                                <img src="/static/uploads/${filePath.split('/').pop()}" alt="${fileName}" 
                                     class="img-thumbnail mb-2" style="max-height: 150px; cursor: pointer;"
                                     onclick="window.open('/static/uploads/${filePath.split('/').pop()}', '_blank')">
                                <button type="button" class="btn btn-sm btn-danger position-absolute top-0 end-0 m-1 delete-file-btn" 
                                        data-file-index="${index}" title="Delete file">
                                    <i class="fas fa-times"></i>
                                </button>
                                <p class="small text-center mb-0">${fileName}</p>
                            </div>
                        `;
                    } else {
                        fileDiv.innerHTML = `
                            <div class="file-attachment text-center p-3 border rounded position-relative">
                                <button type="button" class="btn btn-sm btn-danger position-absolute top-0 end-0 m-1 delete-file-btn" 
                                        data-file-index="${index}" title="Delete file">
                                    <i class="fas fa-times"></i>
                                </button>
                                <i class="${fileIcon} fa-3x text-muted mb-2"></i>
                                <p class="small mb-1">${fileName}</p>
                                <a href="/static/uploads/${filePath.split('/').pop()}" 
                                   class="btn btn-sm btn-outline-primary" download>
                                    <i class="fas fa-download me-1"></i>Download
                                </a>
                            </div>
                        `;
                    }
                    
                    modalNoteFiles.appendChild(fileDiv);
                });
                
                // Add event listeners for delete buttons
                modalNoteFiles.querySelectorAll('.delete-file-btn').forEach(button => {
                    button.addEventListener('click', async (event) => {
                        const fileIndex = parseInt(event.currentTarget.dataset.fileIndex);
                        const fileName = note.file_paths[fileIndex].split('/').pop();
                        
                        if (confirm(`Are you sure you want to delete "${fileName}"? This cannot be undone.`)) {
                            try {
                                const response = await fetch(`/api/notes/${currentNoteIdInModal}/attachments/${fileIndex}`, {
                                    method: 'DELETE'
                                });
                                
                                if (response.ok) {
                                    const result = await response.json();
                                    
                                    // Update the stored note data
                                    const updatedNote = loadedNotes.get(currentNoteIdInModal);
                                    if (updatedNote) {
                                        updatedNote.file_paths = result.file_paths;
                                        loadedNotes.set(currentNoteIdInModal, updatedNote);
                                        
                                        // Refresh the file display and notes list
                                        displayNoteFiles(updatedNote);
                                        await fetchNotes();
                                    }
                                } else {
                                    const data = await response.json();
                                    alert('Error deleting file: ' + (data.error || 'Unknown error'));
                                }
                            } catch (error) {
                                console.error('Error deleting file:', error);
                                alert('An unexpected error occurred while deleting the file.');
                            }
                        }
                    });
                });
                
                // Hide no attachments placeholder
                if (noAttachmentsPlaceholder) {
                    noAttachmentsPlaceholder.style.display = 'none';
                }
            } else {
                modalNoteFiles.appendChild(noAttachmentsPlaceholder);
                noAttachmentsPlaceholder.style.display = 'block';
            }
        }

        // Handle delete note from modal
        deleteNoteFromModalBtn.addEventListener('click', async () => {
            if (currentNoteIdInModal && confirm('Are you sure you want to delete this note? This cannot be undone.')) {
                try {
                    const response = await fetch(`/api/notes/${currentNoteIdInModal}`, {
                        method: 'DELETE',
                    });

                    if (response.ok) {
                        alert('Note deleted successfully!');
                        noteDetailModal.hide();
                        fetchNotes();
                        currentNoteIdInModal = null;
                    } else {
                        const data = await response.json();
                        alert('Error deleting note: ' + (data.error || 'Unknown error'));
                    }
                } catch (error) {
                    console.error('Error deleting note:', error);
                    alert('An unexpected error occurred while deleting the note.');
                }
            }
        });

        // Handle reminder editing
        editReminderBtn.addEventListener('click', () => {
            const note = loadedNotes.get(currentNoteIdInModal);
            if (note && note.reminder) {
                const reminderDate = new Date(note.reminder.scheduled_for);
                editReminderDate.value = reminderDate.toISOString().split('T')[0];
                editReminderTime.value = reminderDate.toTimeString().slice(0, 5);
                
                reminderDisplayMode.style.display = 'none';
                reminderEditMode.style.display = 'block';
            }
        });

        cancelReminderEditBtn.addEventListener('click', () => {
            reminderDisplayMode.style.display = 'block';
            reminderEditMode.style.display = 'none';
        });

        saveReminderBtn.addEventListener('click', async () => {
            if (!editReminderDate.value || !editReminderTime.value) {
                alert('Please enter both date and time for the reminder.');
                return;
            }

            const reminderDateTime = `${editReminderDate.value}T${editReminderTime.value}:00`;
            
            try {
                const response = await fetch(`/api/notes/${currentNoteIdInModal}/reminder`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        scheduled_for: reminderDateTime
                    }),
                });

                if (response.ok) {
                    alert('Reminder updated successfully!');
                    // Refresh the note data and modal display
                    await fetchNotes();
                    const updatedNote = loadedNotes.get(currentNoteIdInModal);
                    if (updatedNote) {
                        // Update the modal display
                        const modalReminderDate = document.getElementById('modalReminderDate');
                        const modalReminderStatus = document.getElementById('modalReminderStatus');
                        
                        if (updatedNote.reminder) {
                            const reminderDate = new Date(updatedNote.reminder.scheduled_for);
                            modalReminderDate.textContent = reminderDate.toLocaleString();
                            
                            // Update status badge
                            const now = new Date();
                            const isPast = reminderDate <= now;
                            const isRead = updatedNote.reminder.is_read;
                            const isDismissed = updatedNote.reminder.is_dismissed;
                            
                            if (isDismissed) {
                                modalReminderStatus.className = 'badge bg-secondary ms-2';
                                modalReminderStatus.textContent = 'Dismissed';
                            } else if (isPast && !isRead) {
                                modalReminderStatus.className = 'badge bg-danger ms-2';
                                modalReminderStatus.textContent = 'Overdue';
                            } else if (isPast && isRead) {
                                modalReminderStatus.className = 'badge bg-success ms-2';
                                modalReminderStatus.textContent = 'Completed';
                            } else {
                                modalReminderStatus.className = 'badge bg-warning text-dark ms-2';
                                modalReminderStatus.textContent = 'Scheduled';
                            }
                        }
                    }
                    
                    reminderDisplayMode.style.display = 'block';
                    reminderEditMode.style.display = 'none';
                } else {
                    const data = await response.json();
                    alert('Error updating reminder: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error updating reminder:', error);
                alert('An unexpected error occurred while updating the reminder.');
            }
        });

        deleteReminderBtn.addEventListener('click', async () => {
            if (confirm('Are you sure you want to remove this reminder?')) {
                try {
                    const response = await fetch(`/api/notes/${currentNoteIdInModal}/reminder`, {
                        method: 'DELETE',
                    });

                    if (response.ok) {
                        alert('Reminder removed successfully!');
                        // Refresh the note data and hide reminder section
                        await fetchNotes();
                        const modalNoteReminder = document.getElementById('modalNoteReminder');
                        modalNoteReminder.style.display = 'none';
                        
                        reminderDisplayMode.style.display = 'block';
                        reminderEditMode.style.display = 'none';
                    } else {
                        const data = await response.json();
                        alert('Error removing reminder: ' + (data.error || 'Unknown error'));
                    }
                } catch (error) {
                    console.error('Error removing reminder:', error);
                    alert('An unexpected error occurred while removing the reminder.');
                }
            }
        });

        // Handle note content editing
        editNoteContentBtn.addEventListener('click', () => {
            const currentNote = loadedNotes.get(currentNoteIdInModal);
            if (currentNote) {
                editNoteTitle.value = currentNote.note_title || '';
                editNoteText.value = currentNote.note_text || '';
                noteContentDisplay.style.display = 'none';
                noteContentEditMode.style.display = 'block';
            }
        });

        cancelNoteContentEditBtn.addEventListener('click', () => {
            noteContentDisplay.style.display = 'block';
            noteContentEditMode.style.display = 'none';
        });

        saveNoteContentBtn.addEventListener('click', async () => {
            try {
                const formData = new FormData();
                formData.append('note_title', editNoteTitle.value.trim());
                formData.append('note_text', editNoteText.value.trim());

                const response = await fetch(`/api/notes/${currentNoteIdInModal}`, {
                    method: 'PUT',
                    body: formData
                });

                if (response.ok) {
                    const result = await response.json();
                    
                    // Update the stored note data
                    const updatedNote = loadedNotes.get(currentNoteIdInModal);
                    if (updatedNote) {
                        updatedNote.note_title = result.note_title;
                        updatedNote.note_text = result.note_text;
                        loadedNotes.set(currentNoteIdInModal, updatedNote);
                        
                        // Update modal display
                        modalNoteTitle.textContent = result.note_title || 'No Title';
                        modalNoteContent.textContent = result.note_text;
                        
                        // Refresh notes list to show updated content
                        await fetchNotes();
                    }
                    
                    noteContentDisplay.style.display = 'block';
                    noteContentEditMode.style.display = 'none';
                } else {
                    const data = await response.json();
                    alert('Error updating note: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error updating note:', error);
                alert('An unexpected error occurred while updating the note.');
            }
        });

        // Handle attachment management
        addAttachmentsBtn.addEventListener('click', () => {
            addAttachmentsForm.style.display = 'block';
            addAttachmentsBtn.style.display = 'none';
        });

        cancelAddAttachmentsBtn.addEventListener('click', () => {
            addAttachmentsForm.style.display = 'none';
            addAttachmentsBtn.style.display = 'inline-block';
            additionalFiles.value = '';
        });

        uploadAdditionalFilesBtn.addEventListener('click', async () => {
            const files = additionalFiles.files;
            if (files.length === 0) {
                alert('Please select files to upload.');
                return;
            }

            try {
                const formData = new FormData();
                for (let i = 0; i < files.length; i++) {
                    formData.append('files', files[i]);
                }

                const response = await fetch(`/api/notes/${currentNoteIdInModal}/attachments`, {
                    method: 'POST',
                    body: formData
                });

                if (response.ok) {
                    const result = await response.json();
                    
                    // Update the stored note data
                    const updatedNote = loadedNotes.get(currentNoteIdInModal);
                    if (updatedNote) {
                        updatedNote.file_paths = result.file_paths;
                        loadedNotes.set(currentNoteIdInModal, updatedNote);
                        
                        // Refresh the file display and notes list
                        displayNoteFiles(updatedNote);
                        await fetchNotes();
                    }
                    
                    // Reset form
                    addAttachmentsForm.style.display = 'none';
                    addAttachmentsBtn.style.display = 'inline-block';
                    additionalFiles.value = '';
                } else {
                    const data = await response.json();
                    alert('Error uploading files: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error uploading files:', error);
                alert('An unexpected error occurred while uploading files.');
            }
        });

        // Handle delete entry
        document.getElementById('deleteEntryBtn').addEventListener('click', async () => {
            if (confirm(`Are you sure you want to delete the entry "${currentEntryName}"? This will also delete all associated notes and relationships. This action cannot be undone.`)) {
                try {
                    const response = await fetch(`/api/entries/${entryId}`, {
                        method: 'DELETE',
                    });

                    if (response.ok) {
                        alert('Entry deleted successfully!');
                        // Redirect to home page after successful deletion
                        window.location.href = '/';
                    } else {
                        const data = await response.json();
                        alert('Error deleting entry: ' + (data.error || 'Unknown error'));
                    }
                } catch (error) {
                    console.error('Error deleting entry:', error);
                    alert('An unexpected error occurred while deleting the entry.');
                }
            }
        });

        // --- Entry Editing Section ---
        const originalEntryTypeId = {{ entry.entry_type_id }};
        
        // Toggle entry editor - load entry types when section is shown
        descriptionEditor.addEventListener('show.bs.collapse', async () => {
            // Load entry types before showing the editor
            try {
                const response = await fetch('/api/entry_types');
                const entryTypes = await response.json();
                
                // Clear and populate entry type select
                entryTypeSelect.innerHTML = '';
                entryTypes.forEach(type => {
                    const option = document.createElement('option');
                    option.value = type.id;
                    option.textContent = type.singular_label;
                    if (type.id == originalEntryTypeId) {
                        option.selected = true;
                    }
                    entryTypeSelect.appendChild(option);
                });
                
            } catch (error) {
                console.error('Error loading entry types:', error);
                displayStatus(descriptionStatusMessage, 'Error loading entry types', 'alert-danger');
            }
        });

        // Cancel entry editing
        cancelDescriptionBtn.addEventListener('click', () => {
            const collapse = new bootstrap.Collapse(descriptionEditor, { show: false });
            // Reset all fields to original values
            entryTitleInput.value = {{ entry.title|tojson }};
            descriptionTextarea.value = {{ (entry.description if entry.description is not none else "")|tojson }};
            // Reset entry type to original
            entryTypeSelect.value = originalEntryTypeId;
            // Reset new fields
            statusSelect.value = {{ (entry.status if entry.status else "active")|tojson }};
            {% if entry.show_end_dates %}
            intendedEndDateInput.value = '{{ entry.intended_end_date[:10] if entry.intended_end_date else "" }}';
            actualEndDateInput.value = '{{ entry.actual_end_date[:10] if entry.actual_end_date else "" }}';
            {% endif %}
            // Clear any status messages
            descriptionStatusMessage.className = 'mt-3 d-none';
            // Clear Wikipedia results
            document.getElementById('wikipediaResults').classList.add('d-none');
        });

        saveDescriptionBtn.addEventListener('click', async () => {
            const title = entryTitleInput.value.trim();
            const description = descriptionTextarea.value;
            const entryTypeId = parseInt(entryTypeSelect.value);
            const status = statusSelect.value;
            {% if entry.show_end_dates %}
            const intendedEndDate = intendedEndDateInput.value;
            const actualEndDate = actualEndDateInput.value;
            {% else %}
            const intendedEndDate = null;
            const actualEndDate = null;
            {% endif %}
            
            if (!title) {
                displayStatus(descriptionStatusMessage, 'Entry title is required.', 'alert-danger');
                return;
            }
            
            displayStatus(descriptionStatusMessage, 'Saving changes...', 'alert-info');

            try {
                const response = await fetch(`/api/entries/${entryId}`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ 
                        title: title,
                        description: description,
                        entry_type_id: entryTypeId,
                        status: status,
                        intended_end_date: intendedEndDate,
                        actual_end_date: actualEndDate
                    })
                });

                const data = await response.json();

                if (response.ok) {
                    displayStatus(descriptionStatusMessage, 'Entry updated successfully!', 'alert-success');
                    
                    // Update the display elements
                    entryTitle.textContent = title;
                    descriptionDisplay.textContent = description || 'No description available';
                    
                    // Update consolidated details display (type and status)
                    const selectedOption = entryTypeSelect.options[entryTypeSelect.selectedIndex];
                    const entryTypeLabel = selectedOption ? selectedOption.textContent : 'Unknown';
                    const capitalizedStatus = status.charAt(0).toUpperCase() + status.slice(1);
                    updateDetailsDisplay(entryTypeLabel, capitalizedStatus);
                    
                    // Update consolidated dates display
                    updateDatesDisplay(intendedEndDate, actualEndDate);
                    
                    // Update the page title
                    document.title = document.title.replace(/- .+ -/, `- ${title} -`);
                    
                    // Update breadcrumb
                    const breadcrumbActive = document.querySelector('.breadcrumb-item.active');
                    if (breadcrumbActive) {
                        breadcrumbActive.textContent = title;
                    }
                    
                    // Hide the editor after successful save
                    setTimeout(() => {
                        const collapse = new bootstrap.Collapse(descriptionEditor, { show: false });
                    }, 1500);
                } else {
                    displayStatus(descriptionStatusMessage, `Error: ${data.error || 'Failed to update entry.'}`, 'alert-danger');
                }
            } catch (error) {
                console.error('Network or server error:', error);
                displayStatus(descriptionStatusMessage, 'An unexpected error occurred while updating entry.', 'alert-danger');
            }
        });

        // --- Wikipedia Search Functionality ---
        document.getElementById('searchWikipediaBtn').addEventListener('click', async () => {
            const searchBtn = document.getElementById('searchWikipediaBtn');
            const wikipediaResults = document.getElementById('wikipediaResults');
            const entryTitle = entryTitleInput.value.trim() || currentEntryName; // Use current input value, fallback to original
            
            // Update button state
            searchBtn.disabled = true;
            searchBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-1" role="status" aria-hidden="true"></span> Searching...';
            
            try {
                const response = await fetch(`/api/wikipedia/search/${encodeURIComponent(entryTitle)}`);
                const data = await response.json();
                
                if (data.found) {
                    // Populate Wikipedia results
                    document.getElementById('wikipediaTitle').textContent = data.title;
                    document.getElementById('wikipediaExtract').textContent = data.extract;
                    document.getElementById('wikipediaLink').href = data.url;
                    
                    // Store the extract for later use
                    wikipediaResults.dataset.extract = data.extract;
                    
                    // Show results
                    wikipediaResults.classList.remove('d-none');
                    
                    displayStatus(descriptionStatusMessage, 'Wikipedia article found!', 'alert-success');
                } else {
                    displayStatus(descriptionStatusMessage, data.message || 'No Wikipedia article found', 'alert-warning');
                    wikipediaResults.classList.add('d-none');
                }
            } catch (error) {
                console.error('Wikipedia search error:', error);
                displayStatus(descriptionStatusMessage, 'Error searching Wikipedia', 'alert-danger');
                wikipediaResults.classList.add('d-none');
            } finally {
                // Reset button state
                searchBtn.disabled = false;
                searchBtn.innerHTML = '<i class="fab fa-wikipedia-w me-1"></i> Search Wikipedia';
            }
        });

        // Handle "Use This Description" button
        document.getElementById('useWikipediaBtn').addEventListener('click', () => {
            const wikipediaResults = document.getElementById('wikipediaResults');
            const extract = wikipediaResults.dataset.extract;
            
            if (extract) {
                descriptionTextarea.value = extract;
                displayStatus(descriptionStatusMessage, 'Wikipedia description added! Remember to save.', 'alert-info');
                
                // Hide Wikipedia results after use
                wikipediaResults.classList.add('d-none');
            }
        });

        // --- Generic Status Display Function ---
        function displayStatus(element, message, type) {
            element.classList.remove('d-none', 'alert-success', 'alert-danger', 'alert-warning', 'alert-info');
            element.classList.add('alert', type);
            element.textContent = message;
            setTimeout(() => {
                element.classList.add('d-none');
            }, 5000);
        }

        // --- Related Records Functions (NEW) ---

        async function loadRelatedRecords() {
            loadingRelationships.style.display = 'block';
            relatedRecordsContainer.innerHTML = ''; // Clear previous content

            try {
                // Fetch relationship definitions
                const definitionsResponse = await fetch(`/api/relationship_definitions`);
                const definitions = await definitionsResponse.json();

                // Fetch relationships for the current entry
                const relationshipsResponse = await fetch(`/api/entries/${entryId}/relationships`);
                const relationships = await relationshipsResponse.json();

                // Group relationships by definition ID
                const groupedEntries = relationships.reduce((acc, rel) => {
                    if (!acc[rel.definition_id]) {
                        acc[rel.definition_id] = [];
                    }
                    acc[rel.definition_id].push(rel);
                    return acc;
                }, {});

                renderRelatedRecords(definitions, groupedEntries);
            } catch (error) {
                relatedRecordsContainer.innerHTML = `<p class="text-danger text-center">Error loading related records: ${error.message}</p>`;
            } finally {
                loadingRelationships.style.display = 'none';
            }
        }

        function renderRelatedRecords(definitions, groupedEntries) {
            // Store definitions globally for easy lookup
            allRelationshipDefinitions = definitions;
            
            // Filter definitions to only show those relevant to the current entry type
            const relevantDefinitions = definitions.filter(def => 
                def.entry_type_id_from == currentEntryTypeId || def.entry_type_id_to == currentEntryTypeId
            );
            
            // Show or hide the Related Records section based on whether there are relevant definitions
            const relatedRecordsSection = document.getElementById('relatedRecordsSection');
            if (relevantDefinitions.length === 0) {
                relatedRecordsSection.style.display = 'none';
                return;
            } else {
                relatedRecordsSection.style.display = 'block';
            }
            
            relevantDefinitions.forEach(def => {
                const relatedEntries = groupedEntries[def.id] || [];
                
                // Determine if current entry is the "from" or "to" side of this relationship
                const isFromSide = def.entry_type_id_from == currentEntryTypeId;
                
                // Check the appropriate cardinality based on the current entry's role in the relationship
                const relevantCardinality = isFromSide ? def.cardinality_from : def.cardinality_to;
                const canAddMore = relevantCardinality === -1 || relatedEntries.length < relevantCardinality;

                const cardHtml = `
                    <div class="card mb-3">
                        <div class="card-header d-flex justify-content-between align-items-center">
                            <h5 class="mb-0">${def.name}</h5>
                            <div>
                                <button class="btn btn-sm btn-primary add-new-btn" data-definition-id="${def.id}" ${canAddMore ? '' : 'disabled'}>
                                    Add New
                                </button>
                                <button class="btn btn-sm btn-secondary add-existing-btn" data-definition-id="${def.id}" ${canAddMore ? '' : 'disabled'}>
                                    Add Existing
                                </button>
                            </div>
                        </div>
                        <div class="card-body">
                            <table class="table table-sm">
                                <thead>
                                    <tr>
                                        <th>Related Entry</th>
                                        <th>Actions</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${relatedEntries.map(entry => `
                                        <tr>
                                            <td><a href="/entry/${entry.related_entry_id}" class="text-decoration-none">${entry.related_entry_title}</a></td>
                                            <td>
                                                <button class="btn btn-sm btn-danger delete-related-btn" data-relationship-id="${entry.relationship_id}" title="Delete relationship">
                                                    <i class="fas fa-trash-alt"></i>
                                                </button>
                                            </td>
                                        </tr>
                                    `).join('')}
                                </tbody>
                            </table>
                        </div>
                    </div>
                `;

                relatedRecordsContainer.insertAdjacentHTML('beforeend', cardHtml);
            });

            attachRelatedRecordEventListeners();
        }

        function attachRelatedRecordEventListeners() {
            // Add New Button
            document.querySelectorAll('.add-new-btn').forEach(button => {
                button.addEventListener('click', async function() {
                    const definitionId = this.getAttribute('data-definition-id');
                    const modalHtml = `
                        <div class="modal fade" id="addNewModal" tabindex="-1" aria-labelledby="addNewModalLabel" aria-hidden="true">
                            <div class="modal-dialog">
                                <div class="modal-content">
                                    <div class="modal-header">
                                        <h5 class="modal-title" id="addNewModalLabel">Add New Entry</h5>
                                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                                    </div>
                                    <div class="modal-body">
                                        <form id="addNewForm">
                                            <div class="mb-3">
                                                <label for="newEntryName" class="form-label">Name:</label>
                                                <input type="text" class="form-control" id="newEntryName" required>
                                            </div>
                                            <div class="mb-3">
                                                <label for="newEntryDescription" class="form-label">Description:</label>
                                                <textarea class="form-control" id="newEntryDescription" rows="3"></textarea>
                                                <div class="mt-2">
                                                    <button type="button" class="btn btn-sm btn-outline-primary" id="searchWikipediaDynamicBtn">
                                                        <i class="fab fa-wikipedia-w me-1"></i> Search Wikipedia
                                                    </button>
                                                </div>
                                            </div>
                                            <div id="wikipediaDynamicResults" class="mb-3 d-none">
                                                <div class="card border-info">
                                                    <div class="card-header bg-light">
                                                        <h6 class="mb-0"><i class="fab fa-wikipedia-w me-1"></i> Wikipedia Result</h6>
                                                    </div>
                                                    <div class="card-body">
                                                        <h6 id="wikipediaDynamicTitle" class="card-title"></h6>
                                                        <p id="wikipediaDynamicExtract" class="card-text" style="font-size: 0.9em; max-height: 100px; overflow-y: auto;"></p>
                                                        <div class="d-flex gap-2">
                                                            <button type="button" class="btn btn-sm btn-gray" id="useWikipediaDynamicBtn">Use This Description</button>
                                                            <a id="wikipediaDynamicLink" href="#" target="_blank" class="btn btn-sm btn-outline-secondary">View on Wikipedia</a>
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                            <button type="submit" class="btn btn-primary w-100">Add</button>
                                        </form>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;

                    document.body.insertAdjacentHTML('beforeend', modalHtml);
                    const addNewModal = new bootstrap.Modal(document.getElementById('addNewModal'));
                    addNewModal.show();

                    // Wait for modal to be fully rendered before adding event listener
                    addNewModal._element.addEventListener('shown.bs.modal', function() {
                        // Add Wikipedia search functionality for dynamic modal
                        document.getElementById('searchWikipediaDynamicBtn').addEventListener('click', async () => {
                            const modal = document.getElementById('addNewModal');
                            const searchBtn = modal.querySelector('#searchWikipediaDynamicBtn');
                            const entryNameInput = modal.querySelector('#newEntryName');
                            const wikipediaResults = modal.querySelector('#wikipediaDynamicResults');
                            
                            const entryName = entryNameInput.value.trim();
                            
                            if (!entryName) {
                                alert('Please enter an entry name first to search Wikipedia');
                                return;
                            }
                            
                            // Update button state
                            searchBtn.disabled = true;
                            searchBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-1" role="status" aria-hidden="true"></span> Searching...';
                            
                            try {
                                const response = await fetch(`/api/wikipedia/search/${encodeURIComponent(entryName)}`);
                                const data = await response.json();
                                
                                if (data.found) {
                                    // Populate Wikipedia results
                                    modal.querySelector('#wikipediaDynamicTitle').textContent = data.title;
                                    modal.querySelector('#wikipediaDynamicExtract').textContent = data.extract;
                                    modal.querySelector('#wikipediaDynamicLink').href = data.url;
                                    
                                    // Store the extract for later use
                                    wikipediaResults.dataset.extract = data.extract;
                                    
                                    // Show results
                                    wikipediaResults.classList.remove('d-none');
                                } else {
                                    alert(data.message || 'No Wikipedia article found');
                                    wikipediaResults.classList.add('d-none');
                                }
                            } catch (error) {
                                console.error('Wikipedia search error:', error);
                                alert('Error searching Wikipedia');
                                wikipediaResults.classList.add('d-none');
                            } finally {
                                // Reset button state
                                searchBtn.disabled = false;
                                searchBtn.innerHTML = '<i class="fab fa-wikipedia-w me-1"></i> Search Wikipedia';
                            }
                        });

                        // Handle "Use This Description" button in dynamic modal
                        document.getElementById('useWikipediaDynamicBtn').addEventListener('click', function() {
                            const modal = document.getElementById('addNewModal');
                            const wikipediaResults = modal.querySelector('#wikipediaDynamicResults');
                            const extract = wikipediaResults.dataset.extract;
                            const descriptionTextarea = modal.querySelector('#newEntryDescription');
                            
                            if (extract) {
                                descriptionTextarea.value = extract;
                                // Hide Wikipedia results after use
                                wikipediaResults.classList.add('d-none');
                            }
                        });

                        document.getElementById('addNewForm').addEventListener('submit', function(event) {
                            event.preventDefault(); // Prevent default form submission

                            // Make sure we're getting the field from the correct modal
                            const modal = document.getElementById('addNewModal');
                            const nameField = modal.querySelector('#newEntryName');
                            const rawValue = nameField.value;
                            const name = rawValue.trim();

                        // Detailed logging for debugging
                        console.log('Raw field value:', `"${rawValue}"`);
                        console.log('Trimmed field value:', `"${name}"`);
                        console.log('Field value length:', rawValue.length);
                        console.log('Trimmed value length:', name.length);
                        console.log('Field element:', nameField);

                        // Clear previous validation error styles
                        nameField.classList.remove('is-invalid');

                        // Check if the Name field is empty (using raw value first)
                        if (!rawValue || !name) {
                            console.error('Validation Failed: Name field is empty.');
                            console.error('Raw value empty:', !rawValue);
                            console.error('Trimmed value empty:', !name);
                            nameField.classList.add('is-invalid');
                            alert('Name is required.');
                            return;
                        }

                        // Proceed if the Name field has a value
                        console.log('Validation passed! Name field value:', name);
                        
                        // Get description field value
                        const descriptionField = modal.querySelector('#newEntryDescription');
                        const description = descriptionField.value.trim();

                        // Disable the submit button to prevent double submission
                        const submitButton = modal.querySelector('button[type="submit"]');
                        submitButton.disabled = true;
                        submitButton.textContent = 'Creating...';

                        // Create the new entry and relationship
                        createNewEntryAndRelationship(definitionId, name, description, addNewModal, submitButton);
                    });
                });
                });
            });

            // Add Existing Button
            document.querySelectorAll('.add-existing-btn').forEach(button => {
                button.addEventListener('click', async function() {
                    const definitionId = this.getAttribute('data-definition-id');
                    
                    // Get the relationship definition to determine which entry type we need
                    const relationshipDef = allRelationshipDefinitions.find(def => def.id == definitionId);
                    if (!relationshipDef) {
                        alert('Relationship definition not found');
                        return;
                    }
                    
                    // Determine which entry type the related entry should be
                    const isCurrentEntryFromSide = relationshipDef.entry_type_id_from == currentEntryTypeId;
                    const targetEntryTypeId = isCurrentEntryFromSide ? relationshipDef.entry_type_id_to : relationshipDef.entry_type_id_from;
                    const targetEntryTypeLabel = isCurrentEntryFromSide ? relationshipDef.entry_type_to_label : relationshipDef.entry_type_from_label;
                    
                    const modalHtml = `
                        <div class="modal fade" id="addExistingModal" tabindex="-1" aria-labelledby="addExistingModalLabel" aria-hidden="true">
                            <div class="modal-dialog">
                                <div class="modal-content">
                                    <div class="modal-header">
                                        <h5 class="modal-title" id="addExistingModalLabel">Add Existing ${targetEntryTypeLabel}</h5>
                                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                                    </div>
                                    <div class="modal-body">
                                        <form id="addExistingForm">
                                            <div class="mb-3">
                                                <label for="entrySearchInput" class="form-label">Search for ${targetEntryTypeLabel}:</label>
                                                <input type="text" class="form-control" id="entrySearchInput" placeholder="Type to search..." autocomplete="off">
                                                <div id="searchResults" class="mt-2" style="max-height: 200px; overflow-y: auto; border: 1px solid #dee2e6; border-radius: 4px; display: none;">
                                                    <!-- Search results will appear here -->
                                                </div>
                                                <input type="hidden" id="selectedEntryId" required>
                                                <div id="selectedEntryDisplay" class="mt-2 p-2 bg-light rounded" style="display: none;">
                                                    <small class="text-muted">Selected:</small>
                                                    <div id="selectedEntryName" class="fw-bold"></div>
                                                    <button type="button" class="btn btn-sm btn-outline-secondary mt-1" id="clearSelection">Clear Selection</button>
                                                </div>
                                            </div>
                                            <button type="submit" class="btn btn-primary w-100" id="addExistingSubmitBtn" disabled>Add Relationship</button>
                                        </form>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;

                    document.body.insertAdjacentHTML('beforeend', modalHtml);
                    const addExistingModal = new bootstrap.Modal(document.getElementById('addExistingModal'));
                    addExistingModal.show();

                    // Get already related entry IDs for this definition to exclude them
                    const alreadyRelatedIds = new Set();
                    try {
                        const relResponse = await fetch(`/api/entries/${entryId}/relationships`);
                        const relationships = await relResponse.json();
                        relationships.forEach(rel => {
                            if (rel.definition_id == definitionId) {
                                alreadyRelatedIds.add(rel.related_entry_id);
                            }
                        });
                        // Also exclude the current entry itself
                        alreadyRelatedIds.add(parseInt(entryId));
                    } catch (error) {
                        console.error('Error fetching existing relationships:', error);
                    }

                    // Search functionality
                    const searchInput = document.getElementById('entrySearchInput');
                    const searchResults = document.getElementById('searchResults');
                    const selectedEntryId = document.getElementById('selectedEntryId');
                    const selectedEntryDisplay = document.getElementById('selectedEntryDisplay');
                    const selectedEntryName = document.getElementById('selectedEntryName');
                    const submitBtn = document.getElementById('addExistingSubmitBtn');
                    const clearBtn = document.getElementById('clearSelection');
                    
                    let searchTimeout;
                    
                    searchInput.addEventListener('input', function() {
                        clearTimeout(searchTimeout);
                        const query = this.value.trim();
                        
                        if (query.length < 2) {
                            searchResults.style.display = 'none';
                            return;
                        }
                        
                        searchTimeout = setTimeout(async () => {
                            try {
                                const response = await fetch(`/api/search_entries?q=${encodeURIComponent(query)}&entry_type_id=${targetEntryTypeId}`);
                                const entries = await response.json();
                                
                                // Filter out already related entries
                                const availableEntries = entries.filter(entry => !alreadyRelatedIds.has(entry.id));
                                
                                if (availableEntries.length === 0) {
                                    searchResults.innerHTML = '<div class="p-2 text-muted">No available entries found</div>';
                                } else {
                                    searchResults.innerHTML = availableEntries.map(entry => 
                                        `<div class="search-result-item p-2 border-bottom" data-entry-id="${entry.id}" data-entry-name="${entry.title}" style="cursor: pointer;">
                                            <div class="fw-semibold">${entry.title}</div>
                                            <small class="text-muted">${entry.entry_type_label}</small>
                                        </div>`
                                    ).join('');
                                    
                                    // Add click handlers for search results
                                    document.querySelectorAll('.search-result-item').forEach(item => {
                                        item.addEventListener('click', function() {
                                            const entryIdValue = this.getAttribute('data-entry-id');
                                            const entryName = this.getAttribute('data-entry-name');
                                            
                                            selectedEntryId.value = entryIdValue;
                                            selectedEntryName.textContent = entryName;
                                            selectedEntryDisplay.style.display = 'block';
                                            searchResults.style.display = 'none';
                                            searchInput.value = '';
                                            submitBtn.disabled = false;
                                        });
                                        
                                        // Add hover effect
                                        item.addEventListener('mouseenter', function() {
                                            this.style.backgroundColor = '#f8f9fa';
                                        });
                                        item.addEventListener('mouseleave', function() {
                                            this.style.backgroundColor = '';
                                        });
                                    });
                                }
                                
                                searchResults.style.display = 'block';
                            } catch (error) {
                                searchResults.innerHTML = '<div class="p-2 text-danger">Error searching entries</div>';
                                searchResults.style.display = 'block';
                            }
                        }, 300);
                    });
                    
                    // Clear selection handler
                    clearBtn.addEventListener('click', function() {
                        selectedEntryId.value = '';
                        selectedEntryDisplay.style.display = 'none';
                        submitBtn.disabled = true;
                        searchInput.focus();
                    });
                    
                    // Hide search results when clicking outside
                    document.addEventListener('click', function(e) {
                        if (!searchResults.contains(e.target) && e.target !== searchInput) {
                            searchResults.style.display = 'none';
                        }
                    });

                    document.getElementById('addExistingForm').addEventListener('submit', async function(event) {
                        event.preventDefault();
                        const relatedEntryId = selectedEntryId.value;
                        
                        if (!relatedEntryId) {
                            alert('Please select an entry first');
                            return;
                        }

                        submitBtn.disabled = true;
                        submitBtn.textContent = 'Adding...';

                        try {
                            const response = await fetch(`/api/entries/${entryId}/relationships`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ definition_id: parseInt(definitionId), related_entry_id: parseInt(relatedEntryId) })
                            });

                            if (response.ok) {
                                alert('Relationship added successfully!');
                                addExistingModal.hide();
                                loadRelatedRecords(); // Refresh the records
                            } else {
                                const error = await response.json();
                                alert(`Error: ${error.error}`);
                            }
                        } catch (error) {
                            alert(`Error: ${error.message}`);
                        } finally {
                            submitBtn.disabled = false;
                            submitBtn.textContent = 'Add Relationship';
                        }
                    });
                    
                    // Clean up modal when closed
                    addExistingModal._element.addEventListener('hidden.bs.modal', function() {
                        document.getElementById('addExistingModal').remove();
                    });
                });
            });

            // Delete Related Button
            document.querySelectorAll('.delete-related-btn').forEach(button => {
                button.addEventListener('click', async function() {
                    const relationshipId = this.getAttribute('data-relationship-id');
                    if (confirm('Are you sure you want to delete this relationship?')) {
                        try {
                            await fetch(`/api/relationships/${relationshipId}`, { method: 'DELETE' });
                            loadRelatedRecords(); // Refresh the records
                        } catch (error) {
                            alert(`Error: ${error.message}`);
                        }
                    }
                });
            });
        }

        // Function to create new entry and establish relationship
        async function createNewEntryAndRelationship(definitionId, entryName, entryDescription, modal, submitButton) {
            try {
                // Find the relationship definition from the already loaded definitions
                let relationshipDef = allRelationshipDefinitions.find(def => def.id == definitionId);
                
                // If not found in cache, fetch all definitions again
                if (!relationshipDef) {
                    const definitionsResponse = await fetch(`/api/relationship_definitions`);
                    if (!definitionsResponse.ok) {
                        throw new Error('Failed to fetch relationship definitions');
                    }
                    allRelationshipDefinitions = await definitionsResponse.json();
                    relationshipDef = allRelationshipDefinitions.find(def => def.id == definitionId);
                }
                
                if (!relationshipDef) {
                    throw new Error('Relationship definition not found');
                }
                
                console.log('Found relationship definition:', relationshipDef);
                
                // Determine which entry type the new entry should be based on the current entry's role
                const isCurrentEntryFromSide = relationshipDef.entry_type_id_from == currentEntryTypeId;
                const newEntryTypeId = isCurrentEntryFromSide ? relationshipDef.entry_type_id_to : relationshipDef.entry_type_id_from;
                
                console.log('Creating entry with:', {
                    title: entryName,
                    description: entryDescription,
                    entry_type_id: newEntryTypeId,
                    currentEntryFromSide: isCurrentEntryFromSide
                });
                
                // Validate that we have the required fields
                if (!entryName || !newEntryTypeId) {
                    console.error('Missing required fields:');
                    console.error('Title (entryName):', entryName);
                    console.error('Entry Type ID:', newEntryTypeId);
                    console.error('Current entry from side:', isCurrentEntryFromSide);
                    throw new Error('Missing required fields for entry creation');
                }
                
                // Create the new entry
                const createEntryResponse = await fetch('/api/entries', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        title: entryName,  // API expects 'title', not 'name'
                        description: entryDescription,
                        entry_type_id: newEntryTypeId // Use the dynamically determined entry type
                    })
                });

                if (!createEntryResponse.ok) {
                    const error = await createEntryResponse.json();
                    console.error('Create entry failed:', error);
                    console.error('Response status:', createEntryResponse.status);
                    throw new Error(error.error || error.message || 'Failed to create new entry');
                }

                const newEntry = await createEntryResponse.json();
                console.log('New entry created:', newEntry);
                
                // Extract entry ID from the redirect URL (format: "/entry/5")
                const newEntryId = newEntry.redirect.split('/').pop();
                console.log('Extracted new entry ID:', newEntryId);

                // Create the relationship between the current entry and the new entry
                console.log('Creating relationship with data:', {
                    definition_id: parseInt(definitionId),
                    related_entry_id: parseInt(newEntryId)
                });
                
                const createRelationshipResponse = await fetch(`/api/entries/${entryId}/relationships`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        definition_id: parseInt(definitionId),
                        related_entry_id: parseInt(newEntryId)
                    })
                });

                if (!createRelationshipResponse.ok) {
                    const error = await createRelationshipResponse.json();
                    console.error('Create relationship failed:', error);
                    console.error('Response status:', createRelationshipResponse.status);
                    throw new Error(error.error || error.message || 'Failed to create relationship');
                }

                console.log('Relationship created successfully');
                alert(`New entry "${entryName}" created and relationship established successfully!`);
                
                // Hide the modal and refresh the related records
                modal.hide();
                loadRelatedRecords();

                // Clean up the modal from DOM
                setTimeout(() => {
                    const modalElement = document.getElementById('addNewModal');
                    if (modalElement) {
                        modalElement.remove();
                    }
                }, 500);

            } catch (error) {
                console.error('Error creating entry and relationship:', error);
                alert(`Error: ${error.message}`);
                
                // Re-enable the submit button
                submitButton.disabled = false;
                submitButton.textContent = 'Add';
            }
        }

        // --- Sensor Data Functions ---
        {% if entry.has_sensors %}
        async function loadSensorData() {
            const sensorDataContainer = document.getElementById('sensorDataContainer');
            const loadingSensorData = document.getElementById('loadingSensorData');
            
            // Check if elements exist before proceeding
            if (!sensorDataContainer) {
                console.error('sensorDataContainer element not found');
                return;
            }
            
            try {
                if (loadingSensorData) {
                    loadingSensorData.style.display = 'block';
                }
                const response = await fetch(`/api/entries/${entryId}/sensor_data`);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const sensorData = await response.json();
                console.log('Loaded sensor data:', sensorData); // Debug log
                renderSensorData(sensorData);
            } catch (error) {
                console.error('Error loading sensor data:', error);
                sensorDataContainer.innerHTML = '<p class="text-danger">Error loading sensor data.</p>';
            } finally {
                if (loadingSensorData) {
                    loadingSensorData.style.display = 'none';
                }
            }
        }

        function renderSensorData(sensorData) {
            const sensorDataContainer = document.getElementById('sensorDataContainer');
            
            // Store data globally for chart functionality
            allSensorData = sensorData;
            
            if (sensorData.length === 0) {
                sensorDataContainer.innerHTML = '<p class="text-muted">No sensor data recorded yet.</p>';
                sensorChartContainer.innerHTML = '<p class="text-muted">No sensor data recorded yet.</p>';
                return;
            }

            // Always render table view for when user switches to it
            renderTableView(sensorData);
            
            // Update chart filters
            updateChartFilters(sensorData);
            
            // Show chart view by default (or if chart view is active)
            if (!chartViewBtn || chartViewBtn.checked) {
                renderChartView();
            }
        }

        function renderTableView(sensorData) {
            const sensorDataContainer = document.getElementById('sensorDataContainer');
            
            const tableHtml = `
                <table class="table table-sm table-striped">
                    <thead>
                        <tr>
                            <th>Sensor Type</th>
                            <th>Value</th>
                            <th>Recorded At</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${sensorData.map(data => `
                            <tr>
                                <td>${data.sensor_type}</td>
                                <td>${data.value}</td>
                                <td>${new Date(data.recorded_at).toLocaleString()}</td>
                                <td>
                                    <button class="btn btn-sm btn-danger delete-sensor-btn" data-sensor-id="${data.id}" title="Delete reading">
                                        <i class="fas fa-trash-alt"></i>
                                    </button>
                                </td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            `;
            
            sensorDataContainer.innerHTML = tableHtml;
            attachSensorDataEventListeners();
        }

        function attachSensorDataEventListeners() {
            // Delete sensor data buttons
            document.querySelectorAll('.delete-sensor-btn').forEach(button => {
                button.addEventListener('click', async function() {
                    const sensorId = this.getAttribute('data-sensor-id');
                    if (confirm('Are you sure you want to delete this sensor reading?')) {
                        await deleteSensorData(sensorId);
                    }
                });
            });
        }

        async function deleteSensorData(sensorId) {
            try {
                const response = await fetch(`/api/sensor_data/${sensorId}`, {
                    method: 'DELETE'
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || 'Failed to delete sensor data');
                }

                // Reload sensor data
                await loadSensorData();
                
            } catch (error) {
                console.error('Error deleting sensor data:', error);
                alert('Error deleting sensor data: ' + error.message);
            }
        }

        function initializeSensorDataForm() {
            const addSensorDataForm = document.getElementById('addSensorDataForm');
            const addSensorDataModal = bootstrap.Modal.getInstance(document.getElementById('addSensorDataModal')) || 
                                      new bootstrap.Modal(document.getElementById('addSensorDataModal'));
            
            // Function to set current date/time
            function setCurrentDateTime() {
                const now = new Date();
                const localDateTime = new Date(now.getTime() - now.getTimezoneOffset() * 60000).toISOString().slice(0, 16);
                document.getElementById('sensorRecordedAt').value = localDateTime;
            }
            
            // Function to populate sensor types dropdown
            async function populateSensorTypes() {
                try {
                    // Use the entry type's enabled sensor types
                    const sensorTypes = enabledSensorTypes ? enabledSensorTypes.split(',').map(type => type.trim()).filter(type => type !== '') : [];
                    
                    const sensorTypeSelect = document.getElementById('sensorTypeInput');
                    // Clear existing options except the first one
                    sensorTypeSelect.innerHTML = '<option value="" disabled selected>Select a sensor type</option>';
                    
                    if (sensorTypes.length === 0) {
                        // No sensor types enabled for this entry type
                        sensorTypeSelect.innerHTML = '<option value="" disabled selected>No sensor types configured for this entry type</option>';
                        return;
                    }
                    
                    // Add enabled sensor type options
                    sensorTypes.forEach(sensorType => {
                        const option = document.createElement('option');
                        option.value = sensorType;
                        option.textContent = sensorType;
                        sensorTypeSelect.appendChild(option);
                    });
                } catch (error) {
                    console.error('Error loading sensor types:', error);
                    // Fallback to some default sensor types
                    const sensorTypeSelect = document.getElementById('sensorTypeInput');
                    sensorTypeSelect.innerHTML = `
                        <option value="" disabled selected>Select a sensor type</option>
                        <option value="Temperature">Temperature</option>
                        <option value="Humidity">Humidity</option>
                        <option value="Pressure">Pressure</option>
                    `;
                }
            }
            
            // Set current date/time as default on initialization
            setCurrentDateTime();
            
            // Populate sensor types dropdown
            populateSensorTypes();
            
            // Reset date/time each time the modal is shown
            document.getElementById('addSensorDataModal').addEventListener('shown.bs.modal', function() {
                setCurrentDateTime();
            });
            
            addSensorDataForm.addEventListener('submit', async function(e) {
                e.preventDefault();
                
                const sensorType = document.getElementById('sensorTypeInput').value;
                const sensorValue = document.getElementById('sensorValueInput').value.trim();
                const recordedAt = document.getElementById('sensorRecordedAt').value;
                
                if (!sensorType || !sensorValue) {
                    alert('Please fill in all required fields.');
                    return;
                }
                
                try {
                    const response = await fetch(`/api/entries/${entryId}/sensor_data`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            sensor_type: sensorType,
                            value: sensorValue,
                            recorded_at: recordedAt || new Date().toISOString()
                        })
                    });
                    
                    console.log('Sensor data POST response status:', response.status); // Debug log
                    
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.error || 'Failed to add sensor data');
                    }
                    
                    const result = await response.json();
                    console.log('Sensor data added successfully:', result); // Debug log
                    
                    // Reset form and close modal
                    addSensorDataForm.reset();
                    setCurrentDateTime(); // Reset to current time
                    addSensorDataModal.hide();
                    
                    // Reload sensor data to show the new entry
                    console.log('Reloading sensor data...'); // Debug log
                    await loadSensorData();
                    
                } catch (error) {
                    console.error('Error adding sensor data:', error);
                    alert('Error adding sensor data: ' + error.message);
                }
            });
        }

        // Chart Functions
        function initializeChartControls() {
            // Initialize DOM element references
            chartTypeSelect = document.getElementById('chartTypeSelect');
            sensorTypeFilter = document.getElementById('sensorTypeFilter');
            timeRangeFilter = document.getElementById('timeRangeFilter');
            tableViewBtn = document.getElementById('tableView');
            chartViewBtn = document.getElementById('chartView');
            sensorChartContainer = document.getElementById('sensorChartContainer');
            
            // Set initial visibility based on default selection (chart view)
            if (sensorDataContainer && sensorChartContainer) {
                sensorDataContainer.style.display = 'none';
                sensorChartContainer.style.display = 'block';
            }
            
            // View toggle event listeners
            if (tableViewBtn) {
                tableViewBtn.addEventListener('change', function() {
                    if (this.checked) {
                        sensorDataContainer.style.display = 'block';
                        sensorChartContainer.style.display = 'none';
                    }
                });
            }

            if (chartViewBtn) {
                chartViewBtn.addEventListener('change', function() {
                    if (this.checked) {
                        sensorDataContainer.style.display = 'none';
                        sensorChartContainer.style.display = 'block';
                        renderChartView();
                    }
                });
            }

            // Chart control event listeners
            if (chartTypeSelect) {
                chartTypeSelect.addEventListener('change', renderChartView);
            }
            if (sensorTypeFilter) {
                sensorTypeFilter.addEventListener('change', renderChartView);
            }
            if (timeRangeFilter) {
                timeRangeFilter.addEventListener('change', renderChartView);
            }
        }

        function updateChartFilters(sensorData) {
            if (!sensorTypeFilter) return;
            
            // Get unique sensor types
            const sensorTypes = [...new Set(sensorData.map(d => d.sensor_type))];
            
            // Clear and repopulate sensor type filter
            sensorTypeFilter.innerHTML = '<option value="all">All Sensor Types</option>';
            sensorTypes.forEach(type => {
                const option = document.createElement('option');
                option.value = type;
                option.textContent = type;
                sensorTypeFilter.appendChild(option);
            });
        }

        function getFilteredSensorData() {
            let filteredData = [...allSensorData];
            
            // Filter by sensor type
            if (sensorTypeFilter && sensorTypeFilter.value !== 'all') {
                filteredData = filteredData.filter(d => d.sensor_type === sensorTypeFilter.value);
            }
            
            // Filter by time range
            if (timeRangeFilter && timeRangeFilter.value !== 'all') {
                const now = new Date();
                let cutoffDate;
                
                switch (timeRangeFilter.value) {
                    case '24h':
                        cutoffDate = new Date(now.getTime() - 24 * 60 * 60 * 1000);
                        break;
                    case '7d':
                        cutoffDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
                        break;
                    case '30d':
                        cutoffDate = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
                        break;
                    default:
                        cutoffDate = new Date(0);
                }
                
                filteredData = filteredData.filter(d => new Date(d.recorded_at) >= cutoffDate);
            }
            
            // Sort by recorded_at
            filteredData.sort((a, b) => new Date(a.recorded_at) - new Date(b.recorded_at));
            
            return filteredData;
        }

        function renderChartView() {
            const canvas = document.getElementById('sensorChart');
            const loadingChart = document.getElementById('loadingChart');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const filteredData = getFilteredSensorData();
            
            // Hide loading message
            if (loadingChart) {
                loadingChart.style.display = 'none';
            }
            
            if (filteredData.length === 0) {
                // Clear chart and show message
                if (sensorChart) {
                    sensorChart.destroy();
                    sensorChart = null;
                }
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.font = '16px Arial';
                ctx.fillStyle = '#6c757d';
                ctx.textAlign = 'center';
                ctx.fillText('No data available for the selected filters', canvas.width / 2, canvas.height / 2);
                return;
            }
            
            // Group data by sensor type for multiple datasets
            const groupedData = {};
            filteredData.forEach(d => {
                if (!groupedData[d.sensor_type]) {
                    groupedData[d.sensor_type] = [];
                }
                groupedData[d.sensor_type].push(d);
            });
            
            // Create datasets
            const datasets = [];
            const colors = [
                'rgba(255, 99, 132, 0.8)',
                'rgba(54, 162, 235, 0.8)',
                'rgba(255, 205, 86, 0.8)',
                'rgba(75, 192, 192, 0.8)',
                'rgba(153, 102, 255, 0.8)',
                'rgba(255, 159, 64, 0.8)',
                'rgba(199, 199, 199, 0.8)',
                'rgba(83, 102, 255, 0.8)'
            ];
            
            let colorIndex = 0;
            Object.keys(groupedData).forEach(sensorType => {
                const data = groupedData[sensorType];
                const color = colors[colorIndex % colors.length];
                
                datasets.push({
                    label: sensorType,
                    data: data.map(d => ({
                        x: new Date(d.recorded_at),
                        y: parseFloat(d.value)
                    })),
                    backgroundColor: color,
                    borderColor: color.replace('0.8', '1'),
                    borderWidth: 2,
                    fill: false,
                    tension: 0.1
                });
                
                colorIndex++;
            });
            
            // Destroy existing chart
            if (sensorChart) {
                sensorChart.destroy();
            }
            
            // Create new chart
            const chartType = chartTypeSelect ? chartTypeSelect.value : 'line';
            
            sensorChart = new Chart(ctx, {
                type: chartType,
                data: {
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                parser: 'YYYY-MM-DDTHH:mm:ss.sssZ',
                                displayFormats: {
                                    millisecond: 'HH:mm:ss.SSS',
                                    second: 'HH:mm:ss',
                                    minute: 'HH:mm',
                                    hour: 'MM/DD HH:mm',
                                    day: 'MM/DD',
                                    week: 'MM/DD',
                                    month: 'MM/YY',
                                    quarter: 'MM/YY',
                                    year: 'YYYY'
                                }
                            },
                            title: {
                                display: true,
                                text: 'Time'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Value'
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Sensor Data Over Time'
                        },
                        legend: {
                            display: Object.keys(groupedData).length > 1
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                title: function(context) {
                                    if (context[0]) {
                                        return new Date(context[0].parsed.x).toLocaleString();
                                    }
                                    return '';
                                }
                            }
                        }
                    },
                    interaction: {
                        mode: 'nearest',
                        axis: 'x',
                        intersect: false
                    }
                }
            });
        }
        {% endif %}

        // Wikipedia search functionality for new relationship modal
        document.getElementById('searchWikipediaNewRelationBtn').addEventListener('click', async () => {
            const searchBtn = document.getElementById('searchWikipediaNewRelationBtn');
            const entryNameInput = document.getElementById('newEntryName');
            const wikipediaResults = document.getElementById('wikipediaNewRelationResults');
            
            const entryName = entryNameInput.value.trim();
            
            if (!entryName) {
                alert('Please enter an entry name first to search Wikipedia');
                return;
            }
            
            // Update button state
            searchBtn.disabled = true;
            searchBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-1" role="status" aria-hidden="true"></span> Searching...';
            
            try {
                const response = await fetch(`/api/wikipedia/search/${encodeURIComponent(entryName)}`);
                const data = await response.json();
                
                if (data.found) {
                    // Populate Wikipedia results
                    document.getElementById('wikipediaNewRelationTitle').textContent = data.title;
                    document.getElementById('wikipediaNewRelationExtract').textContent = data.extract;
                    document.getElementById('wikipediaNewRelationLink').href = data.url;
                    
                    // Store the extract for later use
                    wikipediaResults.dataset.extract = data.extract;
                    
                    // Show results
                    wikipediaResults.classList.remove('d-none');
                } else {
                    alert(data.message || 'No Wikipedia article found');
                    wikipediaResults.classList.add('d-none');
                }
            } catch (error) {
                console.error('Wikipedia search error:', error);
                alert('Error searching Wikipedia');
                wikipediaResults.classList.add('d-none');
            } finally {
                // Reset button state
                searchBtn.disabled = false;
                searchBtn.innerHTML = '<i class="fab fa-wikipedia-w me-1"></i> Search Wikipedia';
            }
        });

        // Handle "Use This Description" button in new relationship modal
        document.getElementById('useWikipediaNewRelationBtn').addEventListener('click', function() {
            const wikipediaResults = document.getElementById('wikipediaNewRelationResults');
            const extract = wikipediaResults.dataset.extract;
            const descriptionTextarea = document.getElementById('newEntryDescription');
            
            if (extract) {
                descriptionTextarea.value = extract;
                // Hide Wikipedia results after use
                wikipediaResults.classList.add('d-none');
            }
        });

    </script>
    <script src="{{ url_for('static', filename='label_printing.js') }}"></script>
    <script src="{{ url_for('static', filename='notifications.js') }}"></script>
</body>
</html>
